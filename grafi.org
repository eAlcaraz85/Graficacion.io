#+TITLE: Apuntes Graficación
#+LANGUAGE: es
#+LaTeX_HEADER: \usepackage[spanish]{inputenc}
#+SETUPFILE: /home/likcos/Materias/Graficacion/theme-readtheorg-local.setup
#+EXPORT_FILE_NAME: index.html
#+OPTIONS: num:nil
#+HTML_HEAD: <style> #content{max-width:1800px;}</style>
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+OPTIONS: tex:t
#+HTML_MATHJAX: t

* Manual de Instalación de Git
** Instalación en Windows
   - Descarga el instalador desde [https://git-scm.com/].
	 
	 

- Haz clic en el botón “Download for Windows”.
   - Ejecuta el archivo descargado (.exe).
   
   - Configuración de las opciones recomendadas durante la instalación:
     - Seleccionar el editor por defecto (por ejemplo, Vim o Notepad++).
     - Usar Git desde la línea de comandos y aplicaciones de terceros (opción recomendada).
     - Opciones de formato de fin de línea: selecciona la opción predeterminada para Windows.
     
   - Completa la instalación.
   - Verifica la instalación abriendo Git Bash o Command Prompt y ejecutando:
#+BEGIN_SRC bash
git --version
#+END_SRC

** Instalación en macOS

*** Método recomendado: usando Homebrew
   - Si tienes Homebrew instalado, abre la terminal y ejecuta:
#+BEGIN_SRC bash
brew install git
#+END_SRC

*** Método alternativo: paquete descargado
   - Descarga el instalador desde [https://git-scm.com/].
   - Ejecuta el paquete descargado (.dmg).
   - Sigue las instrucciones de instalación.

   - Verifica la instalación abriendo la terminal y ejecutando:
     #+BEGIN_SRC bash
     git --version
     #+END_SRC

** Instalación en Linux (Distribuciones basadas en Debian/Ubuntu)
   - Abre la terminal y ejecuta:
     #+BEGIN_SRC bash
     sudo apt update
     sudo apt install git
     #+END_SRC
     
   - Verifica la instalación ejecutando:
     #+BEGIN_SRC bash
     git --version
     #+END_SRC

** Configuración básica de Git
   - Configura tu nombre de usuario:
     #+BEGIN_SRC bash
     git config --global user.name "Tu Nombre"
     #+END_SRC
     
   - Configura tu correo electrónico:
     #+BEGIN_SRC bash
     git config --global user.email "tuemail@ejemplo.com"
     #+END_SRC

   - Verifica la configuración:
     #+BEGIN_SRC bash
     git config --list
     #+END_SRC

** Actualización de Git
   - *Windows*: Ejecuta el instalador más reciente desde el sitio oficial.
   - *macOS*: Ejecuta:
     #+BEGIN_SRC bash
     brew upgrade git
     #+END_SRC
   - *Linux*: Ejecuta:
     #+BEGIN_SRC bash
     sudo apt update && sudo apt upgrade git
     #+END_SRC



** Configurar Llave SSH con GitHub
*** 1. Verificar si ya tienes una llave SSH
   - Abre la terminal y ejecuta el siguiente comando para verificar si ya tienes llaves SSH generadas:
     #+BEGIN_SRC bash
     ls -al ~/.ssh
     #+END_SRC
     
   - Si ves archivos como `id_rsa` o `id_ed25519`, ya tienes llaves SSH. Si no, continúa con el siguiente paso.

*** 2. Generar una nueva llave SSH
   - Si no tienes una llave SSH, genera una nueva con el siguiente comando (puedes cambiar `ed25519` por `rsa` si lo prefieres):
     #+BEGIN_SRC bash
     ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
     #+END_SRC

   - Cuando se te pregunte por la ubicación del archivo, presiona `Enter` para usar la ubicación predeterminada (`~/.ssh/id_ed25519`).
   - Puedes agregar una contraseña para proteger tu llave, pero también puedes dejarlo en blanco.

*** 3. Añadir la llave SSH al agente SSH
   - Para añadir tu nueva llave SSH al agente, asegúrate de que esté en ejecución:
     #+BEGIN_SRC bash
     eval "$(ssh-agent -s)"
     #+END_SRC

   - Añade la llave SSH al agente:
     #+BEGIN_SRC bash
     ssh-add ~/.ssh/id_ed25519
     #+END_SRC

*** 4. Copiar la llave SSH pública
   - Copia el contenido de tu llave pública para añadirla a GitHub:
     #+BEGIN_SRC bash
     cat ~/.ssh/id_ed25519.pub
     #+END_SRC
     
   - Copia el texto que aparece en la terminal (comienza con `ssh-ed25519` o `ssh-rsa`).

*** 5. Añadir la llave SSH a GitHub
   - Inicia sesión en tu cuenta de GitHub.
   - Ve a la sección de *Settings* (Configuración).
   - En el menú lateral izquierdo, selecciona **SSH and GPG keys**.
   - Haz clic en *New SSH key*.
   - Introduce un título para identificar la llave (por ejemplo, "Mi computadora personal") y pega la llave pública copiada en el campo correspondiente.
   - Haz clic en *Add SSH key*.

*** 6. Probar la conexión SSH con GitHub
   - Para verificar que todo está configurado correctamente, ejecuta el siguiente comando:
     #+BEGIN_SRC bash
     ssh -T git@github.com
     #+END_SRC

   - Si es la primera vez que te conectas, verás una advertencia preguntando si deseas continuar. Escribe `yes`.
   - Si la conexión es exitosa, verás un mensaje similar a:
     #+BEGIN_QUOTE
     Hi username! You've successfully authenticated, but GitHub does not provide shell access.
     #+END_QUOTE

*** 7. Usar la conexión SSH en repositorios de GitHub
   - Para clonar un repositorio usando SSH, utiliza la URL SSH del repositorio:
     #+BEGIN_SRC bash
     git clone git@github.com:usuario/repo.git
     #+END_SRC



** Configurar Llave SSH con GitHub en Windows

1. Git Bash: En Windows, utilizas Git Bash como terminal para ejecutar los comandos, en lugar de la terminal estándar de Linux o macOS.

2. Ruta de las llaves: En Git Bash, las rutas siguen el formato Unix (/c/Users/tu_usuario/.ssh/ en lugar de C:\Users\tu_usuario\.ssh).



*** 1. Abrir Git Bash
   - Abre **Git Bash** (es la terminal que se instala junto con Git en Windows).

*** 2. Verificar si ya tienes una llave SSH
   - En la terminal de Git Bash, ejecuta el siguiente comando para ver si ya tienes llaves SSH generadas:
     #+BEGIN_SRC bash
     ls -al ~/.ssh
     #+END_SRC

   - Si ves archivos como `id_rsa` o `id_ed25519`, ya tienes llaves SSH. Si no, continúa con el siguiente paso.

*** 3. Generar una nueva llave SSH
   - Si no tienes una llave SSH, genera una nueva con el siguiente comando:
     #+BEGIN_SRC bash
     ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
     #+END_SRC

   - Cuando se te pregunte por la ubicación del archivo, presiona `Enter` para usar la ubicación predeterminada (`/c/Users/tu_usuario/.ssh/id_ed25519`).
   - Puedes agregar una contraseña para proteger tu llave, pero también puedes dejar el campo vacío si no deseas protegerla con una contraseña.

*** 4. Añadir la llave SSH al agente SSH
   - Asegúrate de que el agente SSH esté en ejecución. En Git Bash, ejecuta:
     #+BEGIN_SRC bash
     eval "$(ssh-agent -s)"
     #+END_SRC

   - Añade tu nueva llave SSH al agente:
     #+BEGIN_SRC bash
     ssh-add ~/.ssh/id_ed25519
     #+END_SRC

*** 5. Copiar la llave SSH pública
   - Para añadir la llave SSH a GitHub, necesitas copiar tu llave pública. Ejecuta el siguiente comando en Git Bash:
     #+BEGIN_SRC bash
     cat ~/.ssh/id_ed25519.pub
     #+END_SRC

   - Copia el texto que aparece en la terminal, que comenzará con `ssh-ed25519` o `ssh-rsa`.

*** 6. Añadir la llave SSH a GitHub
   - Abre tu navegador web e inicia sesión en GitHub.
   - Ve a la sección de *Settings* (Configuración).
   - En el menú lateral izquierdo, selecciona **SSH and GPG keys**.
   - Haz clic en *New SSH key*.
   - Ponle un título descriptivo (como "Mi computadora con Windows") y pega la llave pública copiada en el campo correspondiente.
   - Haz clic en *Add SSH key*.

*** 7. Probar la conexión SSH con GitHub
   - Para asegurarte de que todo está correctamente configurado, prueba la conexión con GitHub desde Git Bash:
     #+BEGIN_SRC bash
     ssh -T git@github.com
     #+END_SRC

   - Si es la primera vez que te conectas, te pedirá confirmar la conexión escribiendo `yes`.
   - Si todo está bien, deberías ver un mensaje como:
     #+BEGIN_QUOTE
     Hi username! You've successfully authenticated, but GitHub does not provide shell access.
     #+END_QUOTE

*** 8. Usar la conexión SSH en repositorios de GitHub
   - Para clonar un repositorio usando la URL SSH, ejecuta:
     #+BEGIN_SRC bash
     git clone git@github.com:usuario/repo.git
     #+END_SRC

   

   
** Manual de Git en Windows

*** 1. Instalar Git en Windows
   - Visita [https://git-scm.com/](https://git-scm.com/) y descarga el instalador de Git para Windows.
   - Ejecuta el archivo descargado (.exe).
   - Durante la instalación, selecciona las opciones predeterminadas recomendadas.
   - Abre *Git Bash* al finalizar la instalación.

*** 2. Configurar Git
   - Abre *Git Bash* y ejecuta los siguientes comandos para configurar tu identidad:

   #+BEGIN_SRC bash
   git config --global user.name "Tu Nombre"
   git config --global user.email "tuemail@ejemplo.com"
   #+END_SRC

   - Para verificar la configuración:

   #+BEGIN_SRC bash
   git config --list
   #+END_SRC

*** 3. Clonar un repositorio
   - Para clonar un repositorio desde GitHub, usa el siguiente comando:

   #+BEGIN_SRC bash
   git clone https://github.com/usuario/repo.git
   #+END_SRC

   Esto descargará el repositorio a tu computadora.

*** 4. Comandos básicos de Git

   - *Verificar el estado del repositorio*:

   #+BEGIN_SRC bash
   git status
   #+END_SRC

   - *Añadir archivos al área de preparación (staging)*:

   #+BEGIN_SRC bash
   git add nombre_de_archivo
   #+END_SRC

   - Para añadir todos los archivos modificados:

   #+BEGIN_SRC bash
   git add .
   #+END_SRC

   - *Hacer un commit* (guardar los cambios localmente):

   #+BEGIN_SRC bash
   git commit -m "Mensaje de commit"
   #+END_SRC

   - *Enviar los cambios al repositorio remoto*:

   #+BEGIN_SRC bash
   git push
   #+END_SRC

*** 5. Actualizar el repositorio local
   - Para obtener los últimos cambios del repositorio remoto:

   #+BEGIN_SRC bash
   git pull
   #+END_SRC

*** 6. Crear y cambiar de ramas (branches)

   - *Crear una nueva rama*:

   #+BEGIN_SRC bash
   git branch nombre_de_la_rama
   #+END_SRC

   - *Cambiar a una rama existente*:

   #+BEGIN_SRC bash
   git checkout nombre_de_la_rama
   #+END_SRC

   - *Crear y cambiar a una nueva rama*:

   #+BEGIN_SRC bash
   git checkout -b nombre_de_la_rama
   #+END_SRC

*** 7. Ver historial de commits

   - Para ver el historial de cambios del repositorio:

   #+BEGIN_SRC bash
   git log
   #+END_SRC

   - Para un historial más compacto:

   #+BEGIN_SRC bash
   git log --oneline
   #+END_SRC

*** 8. Configurar una llave SSH

   - *Generar una llave SSH*:

   #+BEGIN_SRC bash
   ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
   #+END_SRC

   - *Añadir la llave al agente SSH*:

   #+BEGIN_SRC bash
   eval "$(ssh-agent -s)"
   ssh-add ~/.ssh/id_ed25519
   #+END_SRC

   - *Copiar la llave pública*:

   #+BEGIN_SRC bash
   cat ~/.ssh/id_ed25519.pub
   #+END_SRC

   - Añádela a tu cuenta de GitHub en *Settings > SSH and GPG keys*.

   
* Manual de Instalación de Python en Windows

** Paso 1: Descarga de Python
   1. Abre el navegador web y visita el sitio: [[https://www.python.org][https://www.python.org]].
   2. Ve a la pestaña "Downloads" y selecciona la versión más reciente para Windows.
   3. Haz clic en el botón que dice "Download Python (versión actual)" para descargar el instalador de Python.

** Paso 2: Ejecutar el instalador
   1. Ejecuta el archivo descargado (.exe).
   2. Asegúrate de marcar la opción ~Add Python to PATH~ antes de proceder con la instalación.
   3. Haz clic en ~Install Now~ para instalar con la configuración predeterminada.
   4. Espera a que finalice el proceso de instalación y verifica el mensaje de éxito.

** Paso 3: Verificación de la instalación
   1. Abre la línea de comandos (cmd) escribiendo "cmd" en el menú de inicio.
   2. Verifica que Python se instaló correctamente ejecutando el siguiente comando:
      #+BEGIN_SRC bash
      python --version
      #+END_SRC
   3. Abre el intérprete de Python escribiendo ~python~ en la línea de comandos:
      #+BEGIN_SRC bash
      python
      #+END_SRC
      Si todo está bien, verás el prompt interactivo de Python (tres símbolos ~>>>~).
   4. Para salir del intérprete, escribe ~exit()~ o presiona ~Ctrl + Z~ seguido de ~Enter~.

** Paso 4: Instalar pip y otros paquetes
   1. Verifica si pip está instalado escribiendo en la línea de comandos:
      #+BEGIN_SRC bash
      pip --version
      #+END_SRC
   2. Si necesitas instalar paquetes, usa pip con el siguiente comando:
      #+BEGIN_SRC bash
      pip install nombre_paquete
      #+END_SRC

** Paso 5: Configuración del entorno de desarrollo
   1. Instala un editor de código como:
      - [[https://code.visualstudio.com][Visual Studio Code]]
      - [[https://www.jetbrains.com/pycharm/][PyCharm]]
   2. Configura el editor instalando las extensiones de Python. En Visual Studio Code, busca la extensión "Python" en el panel de extensiones.

** Paso 6: Actualización de Python (opcional)
   - Para actualizar Python a una nueva versión en el futuro, descarga la última versión desde [[https://www.python.org/downloads/][python.org]] y sigue los pasos de instalación.


* Introducción a la Graficación por computadora 
   
** Graficación por Computadora

La  Graficación por Computadora (o simplemente Graficación)
se enfoca en el estudio y aplicación de técnicas, algoritmos y
herramientas para la generación y manipulación de imágenes digitales
mediante el uso de computadoras. Es una rama de la informática que
combina conceptos de matemáticas, física y programación para crear
imágenes, animaciones y efectos visuales. A continuación, te describo
los aspectos clave de esta disciplina:

*** Objetivos de la Graficación por Computadora
   1. *Generación de imágenes*: Crear imágenes digitales a partir de descripciones matemáticas y geométricas de objetos, en 2D y 3D.
   2. *Modelado de objetos*: Crear representaciones matemáticas de objetos y escenas usando técnicas como polígonos, mallas y curvas.
   3. *Renderizado*: Convertir representaciones matemáticas en imágenes visuales, simulando iluminación, sombras y texturas.
   4. *Transformaciones geométricas*: Aplicar traslaciones, rotaciones, escalados y proyecciones a objetos en sistemas de coordenadas 2D y 3D.
   5. *Iluminación y sombreado*: Simular cómo la luz interactúa con los objetos para crear efectos realistas.
   6. *Animación*: Generar secuencias de imágenes que cambian a lo largo del tiempo, incluyendo movimientos y simulaciones físicas.
   7. *Texturizado*: Aplicar imágenes (texturas) sobre superficies para dar detalles visuales sin aumentar la complejidad geométrica.
   8. *Interacción gráfica*: Estudiar técnicas para interactuar con imágenes o modelos gráficos, como interfaces gráficas, realidad aumentada o virtual.

*** Áreas de estudio en Graficación por Computadora
   1. *Matemáticas*: Uso de geometría y álgebra lineal para realizar transformaciones geométricas y modelar objetos.
   2. *Programación*: Conocimiento de lenguajes como C++, Python, GLSL y HLSL para implementar algoritmos gráficos.
   3. *Algoritmos gráficos*: Estudio de algoritmos como el trazado de rayos (ray tracing), rasterización y z-buffering.
   4. *Herramientas gráficas*: Uso de APIs como OpenGL, DirectX o Vulkan para crear gráficos y animaciones.
   5. *Física aplicada*: Simulación de fenómenos físicos como gravedad y movimiento para generar gráficos realistas.

*** Aplicaciones de la Graficación por Computadora
   - *Videojuegos*: Creación de ambientes, personajes y efectos visuales.
   - *Cine y efectos visuales*: Creación de efectos especiales y animación por computadora.
   - *Diseño industrial y arquitectónico*: Modelado y visualización de prototipos y estructuras.
   - *Simulaciones*: Uso en medicina, aeronáutica y otras industrias para crear simulaciones realistas.
   - *Realidad virtual y aumentada*: Generación de entornos interactivos virtuales.

*** Temas principales en Graficación por Computadora
   - *Modelado 2D y 3D*
   - *Algoritmos de rasterización*
   - *Transformaciones y proyecciones*
   - *Renderizado y sombreado*
   - *Texturizado*
   - *Iluminación global y local*
   - *Técnicas de animación*
   - *Programación de shaders*
   - *Interacción gráfica y diseño de interfaces*
   

** Modelos de Color: RGB, CMY, HSV y HSL

** Introducción
Los *modelos de color* son representaciones matemáticas que describen
cómo los colores pueden representarse en diversas formas utilizando
valores numéricos. Estos modelos son esenciales en gráficos por
computadora, procesamiento de imágenes y en la percepción del color. A
continuación, se detallan los modelos más comunes: RGB, CMY, HSV y
HSL.

** Modelo de Color RGB (Red, Green, Blue)

** Definición
El modelo de color *RGB* (Rojo, Verde, Azul) es un modelo de mezcla aditiva, que se utiliza principalmente en dispositivos que emiten luz, como pantallas, cámaras digitales y proyectores. Los tres colores primarios (Rojo, Verde y Azul) se combinan de diferentes maneras para crear una amplia gama de colores.

** Funcionamiento de la Mezcla Aditiva
En el modelo RGB, los colores se generan mediante la combinación de luz. Cuanto más intensa es la luz en cada canal (rojo, verde o azul), más claro es el color resultante. Cuando todas las intensidades están al máximo, el color resultante es blanco; cuando todas las intensidades están al mínimo, el resultado es negro.

- *Fórmula para la mezcla aditiva*:
  \[
  \text{Color} = R \cdot \mathbf{r} + G \cdot \mathbf{g} + B \cdot \mathbf{b}
  \]
  donde:
  - \(R\), \(G\) y \(B\) son las intensidades de los canales rojo, verde y azul, respectivamente.
  - \( \mathbf{r} \), \( \mathbf{g} \) y \( \mathbf{b} \) son los vectores unitarios que representan los colores primarios.

- *Ejemplo*:
  - Si \( R = 255 \), \( G = 0 \), \( B = 0 \), obtenemos un color rojo puro.
  - Si \( R = 0 \), \( G = 255 \), \( B = 0 \), obtenemos un color verde puro.
  - Si \( R = 255 \), \( G = 255 \), \( B = 0 \), obtenemos el color amarillo.

** Espacio de Color RGB
El espacio de color *RGB* puede representarse como un cubo tridimensional, donde:
  - El eje X corresponde al canal rojo (\(R\)),
  - El eje Y al canal verde (\(G\)),
  - Y el eje Z al canal azul (\(B\)).
  
Cada vértice del cubo representa un color primario o la combinación de ellos, como se muestra a continuación:
  - \( (0, 0, 0) \): Negro (ausencia de luz).
  - \( (255, 0, 0) \): Rojo.
  - \( (0, 255, 0) \): Verde.
  - \( (0, 0, 255) \): Azul.
  - \( (255, 255, 255) \): Blanco (máxima intensidad en todos los canales).
  - \( (255, 255, 0) \): Amarillo (combinación de rojo y verde).

Este espacio de color es útil para representar los colores generados en dispositivos electrónicos, ya que estos emiten luz en diferentes combinaciones de rojo, verde y azul.

** Conversión a otros modelos de color
El modelo RGB puede convertirse a otros espacios de color como *CMY*, *HSV* o *HSL*. A continuación se muestra la conversión básica de RGB a CMY:

- *Conversión de RGB a CMY*:
  \[
  C = 1 - \left( \frac{R}{255} \right), \quad M = 1 - \left( \frac{G}{255} \right), \quad Y = 1 - \left( \frac{B}{255} \right)
  \]
  donde \(R\), \(G\), y \(B\) son las intensidades de los canales en el rango de [0, 255].

** Aplicaciones del Modelo RGB
El modelo de color RGB se usa ampliamente en:
- *Monitores y pantallas*: Dispositivos como televisores, monitores de computadora y pantallas de teléfonos móviles utilizan píxeles que emiten luz en diferentes intensidades de rojo, verde y azul para representar imágenes.
- *Cámaras digitales*: Los sensores de las cámaras capturan la luz en estos tres canales para generar imágenes en color.
- *Gráficos por computadora*: El modelo RGB es esencial en software de edición de imágenes, renderizado 3D y creación de gráficos visuales.

** Limitaciones del Modelo RGB
Aunque el modelo RGB es excelente para dispositivos que emiten luz, tiene algunas limitaciones:
- No es intuitivo para el ser humano al ajustar el brillo o la saturación de un color, ya que requiere manipular los tres canales de manera independiente.
- El modelo RGB no es el más adecuado para tareas de impresión, ya que en impresiones se usan modelos basados en la mezcla sustractiva de colores, como CMY o CMYK.





** Modelo CMY (Cyan, Magenta, Yellow)
El modelo *CMY* es un modelo de mezcla sustractiva que utiliza los colores cian, magenta y amarillo. Es el modelo base para la impresión en color.

- *Características*:
  - Cada color se describe en términos de cuánto absorbe (resta) de la luz blanca que incide.

- *Mezcla sustractiva*:
  - La relación entre CMY y RGB es:
	\[
	\text{C} = 1 - \left( \frac{R}{L} \right), \quad \text{M} = 1 - \left( \frac{G}{L} \right), \quad \text{Y} = 1 - \left( \frac{B}{L} \right)
	\]

   donde \( L \) es el valor máximo de intensidad (por ejemplo, 255).

- *Conversión de RGB a CMY*:
  - Si los valores RGB están normalizados entre 0 y 1:

	\[
    \text{C} = 1 - R, \quad \text{M} = 1 - G, \quad \text{Y} = 1 - B
    \]

- *Aplicaciones*:
  - Utilizado en la impresión de imágenes en color, como impresoras de inyección de tinta y offset.

** Modelo HSV (Hue, Saturation, Value)
El modelo *HSV* es una representación más intuitiva del color basada en la percepción humana, donde el matiz, la saturación y el valor describen un color.

- *Características*:
  - *Matiz (Hue, H)*: Representa el ángulo en el círculo cromático, en grados [0°, 360°).
  - *Saturación (S)*: Indica la pureza del color, rango de [0,1].
  - *Valor (V)*: Define el brillo del color, rango de [0,1].

- *Conversión de RGB a HSV*:
  - Primero, normalizar los valores RGB entre 0 y 1:
	\[
    R' = \frac{R}{L}, \quad G' = \frac{G}{L}, \quad B' = \frac{B}{L}
    \]

	donde \( L \) es el valor máximo de intensidad (por ejemplo, 255).

  - Calcular el valor máximo y mínimo:
    \[
    C_{\max} = \max(R', G', B'), \quad C_{\min} = \min(R', G', B')
    \]

  - Diferencia:
    \[
    \Delta = C_{\max} - C_{\min}
    \]

  - *Cálculo del Matiz (H)*:
    \[
    \text{Si } \Delta = 0 \Rightarrow H = 0 \\
    \text{Si } C_{\max} = R' \Rightarrow H = 60^\circ \times \left( \frac{G' - B'}{\Delta} \mod 6 \right) \\
    \text{Si } C_{\max} = G' \Rightarrow H = 60^\circ \times \left( \frac{B' - R'}{\Delta} + 2 \right) \\
    \text{Si } C_{\max} = B' \Rightarrow H = 60^\circ \times \left( \frac{R' - G'}{\Delta} + 4 \right)
    \]

  - *Cálculo de la Saturación (S)*:
    \[
    \text{Si } C_{\max} = 0 \Rightarrow S = 0 \\
    \text{Si no} \Rightarrow S = \frac{\Delta}{C_{\max}}
    \]

  - *Cálculo del Valor (V)*:
    \[
	V = C_{\max}
    \]

- *Aplicaciones*:
  - Edición de imágenes, interfaces de selección de color y en procesamiento de video.

- *Ejemplo*:
  - Convertir RGB (255, 255, 0) a HSV:
    - Normalizar:
      \[
      R' = 1, \quad G' = 1, \quad B' = 0
      \]
    - \( C_{\max} = 1 \), \( C_{\min} = 0 \), \( \Delta = 1 \)
    - Calcular H:
      \[
      H = 60^\circ \times \left( \frac{G' - B'}{\Delta} \mod 6 \right) = 60^\circ \times (1 \mod 6) = 60^\circ
      \]
    - Calcular S:
      \[
      S = \frac{\Delta}{C_{\max}} = \frac{1}{1} = 1
      \]
    - Calcular V:
      \[
      V = C_{\max} = 1
      \]
    - *Resultado*: H = 60°, S = 1, V = 1 (Color amarillo)

*** HSV opencv

*** Tutorial: Umbrales en el Modelo de Color HSV

El espacio de color *HSV* (Hue, Saturation, Value) se utiliza para la segmentación de colores en OpenCV. A continuación, explicaremos los tres parámetros principales y cómo definir umbrales para detectar colores.

*** Definición de los Parámetros del Modelo HSV

- *Hue (H)*: Tono o color básico (rojo, verde, azul, etc.). En OpenCV va de 0 a 179.
- *Saturation (S)*: Intensidad del color. Va de 0 a 255.
- *Value (V)*: Brillo del color. Va de 0 a 255.

*** Detectar un color en el espacio HSV

Puedes definir un rango de color utilizando los valores de Hue, Saturation y Value para segmentar colores específicos en una imagen.

**** Código en Python para detectar un color (Verde)

#+BEGIN_SRC python :results output
import cv2
import numpy as np

# Leer la imagen
img = cv2.imread('imagen.jpg')

# Convertir la imagen al espacio de color HSV
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# Definir el rango inferior y superior para detectar verde
lower_green = np.array([35, 100, 100])  # Hue, Saturación, Brillo mínimos
upper_green = np.array([85, 255, 255])  # Hue, Saturación, Brillo máximos

# Crear una máscara que solo incluya los píxeles dentro del rango
mask = cv2.inRange(hsv, lower_green, upper_green)

# Aplicar la máscara a la imagen original
result = cv2.bitwise_and(img, img, mask=mask)

# Mostrar la imagen original y la imagen con el color detectado
cv2.imshow("Imagen Original", img)
cv2.imshow("Color Detectado", result)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** Explicación de los Parámetros:

- *lower_green = np.array([35, 100, 100])*:
  - El valor mínimo del tono es 35, correspondiente a un verde.
  - La saturación mínima es 100 para evitar colores desaturados.
  - El valor mínimo de brillo es 100 para evitar colores muy oscuros.

- *upper_green = np.array([85, 255, 255])*:
  - El valor máximo del tono es 85, cubriendo tonos verdes claros y oscuros.
  - La saturación máxima es 255 para incluir verdes vibrantes.
  - El valor máximo de brillo es 255 para incluir colores brillantes.

*** Ajustes de los Umbrales

Dependiendo de las condiciones de luz y el color exacto que deseas detectar, puedes ajustar los valores de Hue, Saturación y Brillo:

- **Hue (H)**: Ajusta el rango para detectar tonos específicos del color.
- **Saturation (S)**: Ajusta para incluir colores más o menos saturados.
- **Value (V)**: Ajusta para incluir colores más claros o más oscuros.

*** Ejemplo visual: Rango de tonos para detectar verde

| Color        | Hue (H) | Saturación (S) | Brillo (V) |
|--------------|---------|----------------|------------|
| Verde claro  | 35      | 100            | 100        |
| Verde oscuro | 85      | 255            | 255        |

*** Uso de ~cv2.inRange~

La función ~cv2.inRange()~ crea una máscara binaria donde los píxeles dentro del rango son blancos (255) y los fuera del rango son negros (0).




** Modelo HSL (Hue, Saturation, Lightness)
El modelo *HSL* es similar al modelo HSV, pero en lugar de "valor" utiliza el término *luminosidad (Lightness)*, que representa la cantidad de luz que refleja un color.

- *Características*:
  - *Matiz (Hue, H)*: Mismo que en HSV.
  - *Saturación (S)*: Diferente definición que en HSV.
  - *Luminosidad (L)*: Rango de [0,1], donde 0 es negro, 0.5 es el color puro, y 1 es blanco.

- *Conversión de RGB a HSL*:
  - Normalizar RGB:
    \[
    R' = \frac{R}{L}, \quad G' = \frac{G}{L}, \quad B' = \frac{B}{L}
    \]

  - Calcular \( C_{\max} \) y \( C_{\min} \), y \( \Delta \) como en HSV.

  - **Cálculo de la Luminosidad (L)**:
    \[
    L = \frac{C_{\max} + C_{\min}}{2}
    \]

  - *Cálculo de la Saturación (S)*:
    \[
    \text{Si } \Delta = 0 \Rightarrow S = 0 \\
    \text{Si } L \leq 0.5 \Rightarrow S = \frac{\Delta}{C_{\max} + C_{\min}} \\
    \text{Si } L > 0.5 \Rightarrow S = \frac{\Delta}{2 - (C_{\max} + C_{\min})}
    \]

  - *Cálculo del Matiz (H)*:
    - Igual que en HSV.

- *Aplicaciones*:
  - Herramientas de diseño gráfico y edición de imágenes, donde se necesita un control preciso sobre la luz y el color.

- *Ejemplo*:
  - Convertir RGB (255, 0, 0) a HSL:
    - Normalizar:
      \[
      R' = 1, \quad G' = 0, \quad B' = 0
      \]
    - \( C_{\max} = 1 \), \( C_{\min} = 0 \), \( \Delta = 1 \)
    - Calcular L:
      \[
      L = \frac{1 + 0}{2} = 0.5
      \]
    - Calcular S:
      \[
      S = \frac{\Delta}{C_{\max} + C_{\min}} = \frac{1}{1 + 0} = 1
      \]
    - Calcular H:
      \[
      H = 60^\circ \times \left( \frac{G' - B'}{\Delta} \mod 6 \right) = 0^\circ
      \]
    - **Resultado**: H = 0°, S = 1, L = 0.5 (Color rojo puro)



** Función Bitwise opencv

*** Tutorial: Operaciones Bitwise en OpenCV

Las operaciones bitwise en OpenCV son útiles para realizar
manipulaciones de imágenes como la creación de máscaras, la
combinación de imágenes, o efectos visuales.


**** 1. Operación ~cv2.bitwise_and~

Esta operación realiza una operación AND bit a bit sobre los píxeles
correspondientes de dos imágenes. Devuelve una imagen donde un píxel
será 1 si ambos píxeles en las imágenes de entrada son 1.

#+BEGIN_SRC python :results output
import cv2
import numpy as np

# Crear dos imágenes en negro
img1 = np.zeros((300, 300), dtype=np.uint8)
img2 = np.zeros((300, 300), dtype=np.uint8)

# Dibujar un rectángulo blanco en img1
cv2.rectangle(img1, (50, 50), (250, 250), 255, -1)

# Dibujar un círculo blanco en img2
cv2.circle(img2, (150, 150), 100, 255, -1)

# Aplicar la operación bitwise AND
result = cv2.bitwise_and(img1, img2)

# Mostrar las imágenes
cv2.imshow("img1", img1)
cv2.imshow("img2", img2)
cv2.imshow("AND Result", result)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

**** 2. Operación ~cv2.bitwise_or~

Realiza una operación OR bit a bit entre los píxeles de dos imágenes. El resultado será 1 si al menos uno de los píxeles correspondientes es 1.

#+BEGIN_SRC python :results output
import cv2
import numpy as np

# Crear dos imágenes en negro
img1 = np.zeros((300, 300), dtype=np.uint8)
img2 = np.zeros((300, 300), dtype=np.uint8)

# Dibujar un rectángulo blanco en img1
cv2.rectangle(img1, (50, 50), (250, 250), 255, -1)

# Dibujar un círculo blanco en img2
cv2.circle(img2, (150, 150), 100, 255, -1)

# Aplicar la operación bitwise OR
result = cv2.bitwise_or(img1, img2)

# Mostrar las imágenes
cv2.imshow("img1", img1)
cv2.imshow("img2", img2)
cv2.imshow("OR Result", result)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

**** 3. Operación ~cv2.bitwise_xor~

La operación XOR devuelve una imagen donde un píxel será 1 si exactamente uno de los píxeles correspondientes en las imágenes de entrada es 1.

#+BEGIN_SRC python :results output
import cv2
import numpy as np

# Crear dos imágenes en negro
img1 = np.zeros((300, 300), dtype=np.uint8)
img2 = np.zeros((300, 300), dtype=np.uint8)

# Dibujar un rectángulo blanco en img1
cv2.rectangle(img1, (50, 50), (250, 250), 255, -1)

# Dibujar un círculo blanco en img2
cv2.circle(img2, (150, 150), 100, 255, -1)

# Aplicar la operación bitwise XOR
result = cv2.bitwise_xor(img1, img2)

# Mostrar las imágenes
cv2.imshow("img1", img1)
cv2.imshow("img2", img2)
cv2.imshow("XOR Result", result)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

**** 4. Operación ~cv2.bitwise_not~

La operación NOT invierte los colores de la imagen. Los píxeles blancos se convierten en negros y viceversa.

#+BEGIN_SRC python :results output
import cv2
import numpy as np

# Crear una imagen en negro
img = np.zeros((300, 300), dtype=np.uint8)

# Dibujar un rectángulo blanco
cv2.rectangle(img, (50, 50), (250, 250), 255, -1)

# Aplicar la operación bitwise NOT
result = cv2.bitwise_not(img)

# Mostrar las imágenes
cv2.imshow("Original", img)
cv2.imshow("NOT Result", result)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

**** Ejemplo práctico: Enmascarar una región de interés (ROI)

Aquí aplicamos operaciones bitwise para enmascarar y combinar una imagen.

#+BEGIN_SRC python :results output
import cv2
import numpy as np

# Cargar la imagen principal
img1 = cv2.imread('imagen_principal.jpg')

# Cargar la imagen que queremos enmascarar
img2 = cv2.imread('logo.png')

# Obtener las dimensiones de la segunda imagen (logo)
rows, cols, channels = img2.shape

# Definir la región de interés (ROI) en la imagen principal
roi = img1[0:rows, 0:cols]

# Convertir la imagen del logo a escala de grises
img2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)

# Crear una máscara binaria a partir de la imagen en escala de grises
ret, mask = cv2.threshold(img2gray, 10, 255, cv2.THRESH_BINARY)

# Invertir la máscara
mask_inv = cv2.bitwise_not(mask)

# Hacer visible el fondo de la imagen principal en la región del logo
img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)

# Extraer el logo
img2_fg = cv2.bitwise_and(img2, img2, mask=mask)

# Combinar el fondo y el logo
dst = cv2.add(img1_bg, img2_fg)

# Colocar la imagen combinada en la imagen principal
img1[0:rows, 0:cols] = dst

# Mostrar la imagen final
cv2.imshow("Resultado", img1)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC


** Definición: Operación Bit a Bit

Una **operación bit a bit** (en inglés, *bitwise operation*) es una operación que se realiza directamente sobre los bits de los operandos. Las operaciones se ejecutan sobre los bits correspondientes de los números en formato binario.

*** Principales operaciones bit a bit

**** 1. AND bit a bit (~&~)
Devuelve `1` si ambos bits en la misma posición son `1`, de lo contrario devuelve `0`.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
B = 1100 (12 en decimal)
Resultado: 1000 (8 en decimal)
#+END_EXAMPLE

**** 2. OR bit a bit (~|~)
Devuelve `1` si al menos uno de los bits en la misma posición es `1`, de lo contrario devuelve `0`.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
B = 1100 (12 en decimal)
Resultado: 1110 (14 en decimal)
#+END_EXAMPLE

**** 3. XOR bit a bit (~^~)
Devuelve `1` si los bits en la misma posición son diferentes, y `0` si son iguales.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
B = 1100 (12 en decimal)
Resultado: 0110 (6 en decimal)
#+END_EXAMPLE

**** 4. NOT bit a bit (~~)
Invierte los bits de un número: convierte los `0` en `1` y los `1` en `0`. En sistemas de complemento a dos, esto también implica cambiar el signo de un número entero.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
Resultado: 0101 (-11 en decimal, si estamos usando complemento a dos)
#+END_EXAMPLE

**** 5. Desplazamiento a la izquierda (~<<~)
Desplaza todos los bits del número hacia la izquierda por un número específico de posiciones. Los bits desplazados fuera del límite se descartan y se rellenan con ceros en el extremo derecho.

#+BEGIN_EXAMPLE
A = 0001 (1 en decimal)
A << 2 = 0100 (4 en decimal)
#+END_EXAMPLE

**** 6. Desplazamiento a la derecha (~>>~)
Desplaza todos los bits del número hacia la derecha por un número específico de posiciones. Los bits desplazados fuera del límite se descartan y el bit más significativo depende del signo del número.

#+BEGIN_EXAMPLE
A = 1000 (8 en decimal)
A >> 2 = 0010 (2 en decimal)
#+END_EXAMPLE

**** Aplicaciones de las operaciones bit a bit

- **Máscaras de bits**: Las operaciones bit a bit se usan para aplicar máscaras que seleccionan o modifican partes específicas de un número o secuencia binaria.
- **Manipulación de imágenes**: En procesamiento de imágenes, las operaciones bit a bit son útiles para combinar y modificar píxeles en OpenCV.
- **Optimización de algoritmos**: Las operaciones bit a bit permiten optimizar cálculos en sistemas de bajo nivel o con restricciones de recursos.



** Operadores Puntuales

*** Definición
Los *operadores puntuales* son una clase de transformaciones aplicadas
en el procesamiento digital de imágenes que operan sobre cada píxel de
manera independiente. Esto significa que el valor de salida de un
píxel depende únicamente del valor de ese mismo píxel en la imagen de
entrada, sin considerar los valores de los píxeles vecinos.

*** Características
1. *Independencia espacial*: Los operadores puntuales solo modifican
   cada píxel basado en su valor original, sin tener en cuenta su
   entorno.
2. *Simplicidad computacional*: Dado que no se necesita información de
   los píxeles vecinos, estas operaciones suelen ser más rápidas y
   eficientes.
3. *Aplicación en tiempo real*: Su bajo costo computacional los hace
   adecuados para aplicaciones de procesamiento de imágenes en tiempo
   real.

*** Tipos de Operadores Puntuales

**** Operador de Identidad
   - No altera la imagen. Cada píxel de la imagen de salida tiene el
     mismo valor que el píxel correspondiente en la imagen de entrada.
   - Fórmula: \( g(x, y) = f(x, y) \), donde \( f(x, y) \) es el valor del píxel original y \( g(x, y) \) es el valor del píxel modificado.

**** Negativo de la Imagen
   - Este operador invierte los valores de los píxeles de una imagen, produciendo su negativo.
   - Fórmula: \( g(x, y) = L - 1 - f(x, y) \), donde \( L \) es el valor máximo posible en la imagen (por ejemplo, 255 en imágenes de 8 bits).
   - Uso: Se utiliza en técnicas como la extracción de detalles o cuando es necesario invertir una imagen para un análisis.

**** Umbralización (Thresholding)
   - Convierte la imagen a una versión binaria, donde los píxeles con valores por encima de un umbral se establecen en un valor (generalmente blanco), y los que están por debajo se establecen en otro (generalmente negro).
   - Fórmula: 
     \[
     g(x, y) =
     0, & \text{si } f(x, y) \leq T \\
     L, & \text{si } f(x, y) > T
     \]
   - Uso: Se utiliza para segmentación de imágenes y procesamiento de imágenes en blanco y negro.

**** Corrección Gamma
   - Ajusta los valores de intensidad de los píxeles para modificar el brillo o contraste de la imagen.
   - Fórmula: \( g(x, y) = c \cdot f(x, y)^\gamma \), donde \( c \) es una constante de escala, y \( \gamma \) es el factor de corrección.
   - Uso: Corrige la distorsión de brillo en pantallas o para obtener una mejor representación visual.

**** Transformaciones Logarítmicas
   - Aumentan los detalles en regiones oscuras de la imagen al expandir los valores de intensidad bajos.
   - Fórmula: \( g(x, y) = c \cdot \log(1 + f(x, y)) \), donde \( c \) es una constante.
   - Uso: Mejora la visualización de imágenes con una alta gama dinámica (HDR), como imágenes astronómicas.

**** Corrección Lineal o Estiramiento de Contraste
   - Expande los valores de intensidad en una imagen para cubrir un rango más amplio, aumentando el contraste.
   - Fórmula:
     \[
     g(x, y) = \frac{f(x, y) - f_{\min}}{f_{\max} - f_{\min}} \cdot (L - 1)
     \]
   - Uso: Aumenta el contraste en imágenes con poca variación de intensidad.

**** Transformaciones de Potencia (Raise to Power Transform)
   - Eleva cada valor de píxel a una potencia \( n \), lo que permite ajustar el brillo y contraste de una imagen.
   - Fórmula: \( g(x, y) = c \cdot f(x, y)^n \).

*** Aplicaciones de Operadores Puntuales
- *Corrección de imágenes*: Mejoran el brillo, contraste, y otros aspectos visuales de una imagen.
- *Segmentación*: La umbralización es comúnmente usada para separar objetos de fondo en una imagen.
- *Análisis médico*: Se utiliza para mejorar la visualización de imágenes de rayos X, resonancias magnéticas o ultrasonidos.
- *Procesamiento en tiempo real*: Los operadores puntuales son útiles en sistemas que requieren una rápida respuesta, como cámaras de vigilancia o sistemas de visión artificial.

En resumen, los *operadores puntuales* son una herramienta fundamental en el procesamiento de imágenes que permiten realizar transformaciones sencillas pero efectivas, mejorando la calidad visual o preparándolas para análisis posteriores.



** Proceso de Multiplicación de una Matriz de Transformación por una Coordenada de Píxel

Cuando aplicamos una transformación geométrica a una imagen, multiplicamos las coordenadas de cada píxel por una *matriz de transformación*. Este proceso se desglosa paso a paso de la siguiente manera.

*** 1. Representación de las coordenadas en forma homogénea
Las coordenadas \((x, y)\) de un píxel se convierten a *coordenadas homogéneas* para que las traslaciones puedan representarse mediante multiplicaciones de matrices. Un píxel en coordenadas homogéneas es:

\begin{pmatrix}
x \\
y \\
1
\end{pmatrix}

*** 2. Definición de la matriz de transformación
La matriz de transformación afín general tiene la forma:
\[
T= \begin{pmatrix}
a_{11} & a_{12} & t_x \\
a_{21} & a_{22} & t_y \\
0 & 0 & 1
\end{pmatrix}
\]

- \(a_{11}, a_{12}, a_{21}, a_{22}\) definen las transformaciones de rotación, escalado y cizallamiento.
- \(t_x, t_y\) son los parámetros de traslación en los ejes \(x\) e \(y\).

*** 3. Multiplicación de la matriz por las coordenadas
Multiplicamos la matriz de transformación \(T\) por las coordenadas homogéneas \((x, y, 1)\) para obtener las nuevas coordenadas \((x', y', 1)\).

$$
\begin{pmatrix}
x' \\
y' \\
1
\end{pmatrix}
=
\begin{pmatrix}
a_{11} & a_{12} & t_x \\
a_{21} & a_{22} & t_y \\
0 & 0 & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
x \\
y \\
1
\end{pmatrix}
$$


La multiplicación de matrices se desglosa a continuación.

**** 3.1 Cálculo del nuevo valor de \(x'\)

\[
x' = a_{11} \cdot x + a_{12} \cdot y + t_x
\]

**** 3.2 Cálculo del nuevo valor de \(y'\)
\[
y' = a_{21} \cdot x + a_{22} \cdot y + t_y
\]

**** 3.3 El valor constante de la tercera coordenada
La tercera coordenada se mantiene como \(1\), ya que no cambia en las transformaciones afines.

\[1 = (0 \cdot x) + (0 \cdot y) + 1 \]

*** 4. Resultado final
El resultado de la multiplicación es un nuevo vector con las coordenadas transformadas:

\begin{pmatrix}
x' \\
y' \\
1
\end{pmatrix}

*** Ejemplo concreto: Rotación
Si queremos rotar un píxel \((x, y)\) en un ángulo \(\theta\), usamos la matriz de rotación:

\[
R = \begin{pmatrix}
\cos(\theta) & -\sin(\theta) & 0 \\
\sin(\theta) & \cos(\theta) & 0 \\
0 & 0 & 1
\end{pmatrix}
\]

Multiplicamos esta matriz por las coordenadas homogéneas:

\[
\begin{pmatrix}
x' \\
y' \\
1
\end{pmatrix}
=
\begin{pmatrix}
\cos(\theta) & -\sin(\theta) & 0 \\
\sin(\theta) & \cos(\theta) & 0 \\
0 & 0 & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
x \\
y \\
1
\end{pmatrix}
\]
Esto resulta en las nuevas coordenadas después de la rotación:

\[
x' = x \cdot \cos(\theta) - y \cdot \sin(\theta)
y' = x \cdot \sin(\theta) + y \cdot \cos(\theta)
\]
*** Resumen del proceso
1. Convertir las coordenadas \((x, y)\) a coordenadas homogéneas \((x, y, 1)\).
2. Definir la matriz de transformación \(T\).
3. Multiplicar la matriz \(T\) por las coordenadas homogéneas.
4. Obtener las nuevas coordenadas \((x', y')\) que represe

** Transformaciones Geométricas en Imágenes

Las *transformaciones geométricas* en imágenes permiten cambiar la posición, orientación y escala de las imágenes sin alterar su contenido. Estas transformaciones son esenciales en tareas como alineación de imágenes, registro de imágenes, realidad aumentada, y sistemas de visión por computadora.

*** 1. Traslación (Translation)

   La traslación desplaza la imagen en el espacio sin modificar su forma o tamaño. La fórmula matemática es:

   \[
   T(x, y) = (x + t_x, y + t_y)
   \]

   Donde \(t_x\) y \(t_y\) son las cantidades de desplazamiento. La matriz de traslación es:

   \[
   T = \begin{pmatrix}
   1 & 0 & t_x \\
   0 & 1 & t_y \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 2. Rotación (Rotation)

   La rotación gira la imagen un ángulo \(\theta\). La ecuación de rotación es:

   \[
   R(x, y) = (x' , y') = \left( x \cdot \cos(\theta) - y \cdot \sin(\theta), x \cdot \sin(\theta) + y \cdot \cos(\theta) \right)
   \]

   La matriz de rotación es:

   \[
   R = \begin{pmatrix}
   \cos(\theta) & -\sin(\theta) & 0 \\
   \sin(\theta) & \cos(\theta) & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 3. Escalado (Scalin
g)

   El escalado modifica el tamaño de la imagen mediante factores \(s_x\) y \(s_y\). La fórmula es:

   \[
   S(x, y) = (s_x \cdot x, s_y \cdot y)
   \]

   La matriz correspondiente es:

   \[
   S = \begin{pmatrix}
   s_x & 0 & 0 \\
   0 & s_y & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 4. Cizallamiento (Shearing)

   El cizallamiento inclina la imagen en una dirección específica. Las ecuaciones para un cizallamiento horizontal y vertical son:

   \[
   Sh_x(x, y) = (x + h_x \cdot y, y)
   \]
   \[
   Sh_y(x, y) = (x, y + h_y \cdot x)
   \]

   Las matrices correspondientes son:

   Horizontal:

   \[
   Sh_x = \begin{pmatrix}
   1 & h_x & 0 \\
   0 & 1 & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

   Vertical:

   \[
   Sh_y = \begin{pmatrix}
   1 & 0 & 0 \\
   h_y & 1 & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 5. Reflexión (Reflection)

   La reflexión voltea la imagen sobre un eje. Las matrices para reflexiones sobre el eje \(x\) o \(y\) son:

   \[
   R_x = \begin{pmatrix}
   1 & 0 & 0 \\
   0 & -1 & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

   \[
   R_y = \begin{pmatrix}
   -1 & 0 & 0 \\
   0 & 1 & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 6. Transformación Afín (Affine Transformation)

   Una transformación afín combina varias de las anteriores. Su matriz es:

   \[
   A = \begin{pmatrix}
   a_{11} & a_{12} & t_x \\
   a_{21} & a_{22} & t_y \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 7. Transformación Proyectiva (Homografía)

   La homografía proyecta una imagen en un nuevo plano, alterando su perspectiva. La matriz homográfica es:

   \[
   H = \begin{pmatrix}
   h_{11} & h_{12} & h_{13} \\
   h_{21} & h_{22} & h_{23} \\
   h_{31} & h_{32} & h_{33}
   \end{pmatrix}
   \]

*** Aplicaciones

   Las transformaciones geométricas se utilizan en:

   - *Alineación de imágenes*: Registrar imágenes para tener la misma perspectiva.
   - *Corrección de distorsión*: Corregir distorsiones causadas por lentes de cámaras.
   - *Visión artificial*: Identificar objetos en diferentes orientaciones.
   - *Realidad aumentada*: Ajustar objetos virtuales al mundo real.






   
* Actividades

- Generar una imagen tipo pixel art utilizando una matriz de enteros en el rango de 0 a 255.
- Generar al menos cinco operadores puntuales utilizando la imagen generada o una imagen previamente cargada.
- Aplicar las transformaciones geométricas vistas en clase.
- Investigar qué son las ecuaciones paramétricas.
- Crear un dibujo mediante primitivas de dibujo utilizando OpenCV.
- Programar al menos 10 ecuaciones paramétricas.

Todas las actividades anteriores deben estar documentadas en formato Markdown en el repositorio.  
  

* Programación

** Programas Unidad 1 
*** Creación de una Imagen


#+BEGIN_SRC python
import numpy as np   # Importa la librería NumPy, útil para trabajar con arreglos y operaciones numéricas.
import cv2 as cv     # Importa la librería OpenCV, que se utiliza para procesamiento de imágenes.

# Crea una imagen de 500x500 píxeles, todos con valor 240 (gris claro). 
# La imagen tiene solo un canal (escala de grises) y está inicializada con valores de tipo uint8 (enteros sin signo de 8 bits).
img = np.ones((500, 500), dtype=np.uint8) * 240

# Modifica algunos píxeles específicos en las coordenadas (30, 30) a (30, 35) para que tengan un valor de 1 (casi negro).
# Esto creará una pequeña línea vertical de 6 píxeles en la imagen de color casi negro.
img[30, 30] = 1
img[30, 31] = 1
img[30, 32] = 1
img[30, 33] = 1
img[30, 34] = 1
img[30, 35] = 1

# Muestra la imagen en una ventana con el título 'img'. 
cv.imshow('img', img)

# Espera a que el usuario presione cualquier tecla para continuar.
cv.waitKey()

# Cierra todas las ventanas creadas por OpenCV.
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None

*** Cargar Imagen 
#+BEGIN_SRC python :result output
import cv2 as cv  # Importa la librería OpenCV, que se usa para el procesamiento de imágenes y videos.

# Lee una imagen desde el archivo 'tr.png'. 
# El segundo argumento '1' indica que se leerá la imagen en color (1 para color, 0 para escala de grises, -1 para incluir el canal alfa si existe).
img = cv.imread('tr.png', 1)

# Muestra la imagen leída en una ventana llamada 'ejemplo'.
cv.imshow('ejemplo', img)

# Espera indefinidamente hasta que el usuario presione una tecla.
cv.waitKey(0)

# Cierra todas las ventanas abiertas por OpenCV.
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None

*** Split y Merge Imagen 
#+BEGIN_SRC python :result output
import cv2 as cv  # Importa OpenCV, que es útil para procesamiento de imágenes.
import numpy as np  # Importa NumPy, que es útil para trabajar con matrices y operaciones numéricas.

# Carga la imagen '1a.png' en color (1 para color, 0 para escala de grises).
img = cv.imread('1a.png', 1)

# Crea una imagen vacía (llena de ceros, que representa color negro) con el mismo tamaño que la imagen original.
# La imagen vacía tiene un solo canal (escala de grises), por lo que se usa `img.shape[:2]` para obtener las dimensiones de la imagen (alto, ancho).
img2 = np.zeros((img.shape[:2]), dtype=np.uint8)

# Imprime las dimensiones de la imagen en la terminal (alto, ancho).
print(img.shape[:2])

# Separa los canales rojo (r), verde (g) y azul (b) de la imagen utilizando la función `cv.split()`.
r, g, b = cv.split(img)

# Recombina los canales, pero los reorganiza como rojo, azul y verde (RBG en lugar de RGB).
img3 = cv.merge([r, b, g])

# Crea una imagen que contiene solo el canal rojo, llenando los otros dos canales (verde y azul) con ceros (negro).
r = cv.merge([r, img2, img2])

# Crea una imagen que contiene solo el canal verde, llenando los otros dos canales (rojo y azul) con ceros.
g = cv.merge([img2, g, img2])

# Crea una imagen que contiene solo el canal azul, llenando los otros dos canales (rojo y verde) con ceros.
b = cv.merge([img2, img2, b])

# Muestra la imagen original en una ventana llamada 'ejemplo'.
cv.imshow('ejemplo', img)

# Muestra la imagen que contiene solo el canal rojo.
cv.imshow('r', r)

# Muestra la imagen que contiene solo el canal verde.
cv.imshow('g', g)

# Muestra la imagen que contiene solo el canal azul.
cv.imshow('b', b)

# Muestra la imagen con los canales reorganizados (RBG en lugar de RGB).
cv.imshow('img3', img3)

# Espera indefinidamente a que el usuario presione una tecla.
cv.waitKey(0)

# Cierra todas las ventanas abiertas por OpenCV.
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None

*** Ejemplo de Operador Puntual en Imágenes 
#+BEGIN_SRC python :results output
import cv2 as cv

img = cv.imread('tr.png', 0)
cv.imshow('salida', img)
x,y=img.shape
for i in range(x):
	for j in range(y):
		if(img[i,j]>150):
			img[i,j]=255
		else:
			img[i,j]=0


cv.imshow('negativo', img)
print( img.shape, x , y)
cv.waitKey(0)
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: (632, 635) 632 635

*** Cargar vídeo Opencv 
#+BEGIN_SRC python
import cv2 as cv
import numpy as np
cap = cv.VideoCapture(0)

while(True):
    ret, img = cap.read()
    if ret:
        cv.imshow('video', img)
        img2 = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
        hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
        w,h = img2.shape
        img3=255-img2
        cv.imshow('img2', img2)
        cv.imshow('hsv', hsv)
        cv.imshow('img3', img3)
        
        k =cv.waitKey(1) & 0xFF
        if k == 27 :
	    break
    else:
        break
    
cap.release()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None

 

** Ejemplos de Transformaciones Geométricas en Modo Raw en Python

*** 1. Traslación
En esta transformación, desplazamos la imagen en el espacio sumando un valor fijo a las coordenadas de los píxeles.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Crear una imagen vacía para la traslación
translated_img = np.zeros((x, y), dtype=np.uint8)

# Definir el desplazamiento en x e y
dx, dy = 100, 50

# Trasladar la imagen
for i in range(x):
    for j in range(y):
        new_x = i + dy
        new_y = j + dx
        if 0 <= new_x < x and 0 <= new_y < y:
            translated_img[new_x, new_y] = img[i, j]

# Mostrar la imagen original y la trasladada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Trasladada', translated_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 2. Rotación (alrededor del centro de la imagen)
La rotación se realiza alrededor del centro de la imagen, utilizando las fórmulas matemáticas correspondientes.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np
import math

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Crear una imagen vacía para almacenar el resultado
rotated_img = np.zeros((x*2, y*2), dtype=np.uint8)
xx, yy = rotated_img.shape
# Calcular el centro de la imagen
cx, cy = int(x  // 2), int(y  // 2)

# Definir el ángulo de rotación (en grados) y convertirlo a radianes
angle = 45
theta = math.radians(angle)

# Rotar la imagen
for i in range(x):
    for j in range(y):
        new_x = int((j - cx) * math.cos(theta) - (i - cy) * math.sin(theta) + cx)
        new_y = int((j - cx) * math.sin(theta) + (i - cy) * math.cos(theta) + cy)
        if 0 <= new_x < y and 0 <= new_y < x:
            rotated_img[new_y, new_x] = img[i, j]

# Mostrar la imagen original y la rotada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Rotada (modo raw)', rotated_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None

*** 3. Escalado
El escalado cambia el tamaño de la imagen multiplicando las coordenadas por un factor de escala.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Definir el factor de escala
scale_x, scale_y = 2, 2

# Crear una nueva imagen para almacenar el escalado
scaled_img = np.zeros((int(x * scale_y), int(y * scale_x)), dtype=np.uint8)

# Aplicar el escalado
for i in range(x):
    for j in range(y):
                   #orig_x = int(i * scale_y)
                   #orig_y = int(j * scale_x)
                   scaled_img[i*2, j*2] = img[i, j]

# Mostrar la imagen original y la escalada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Escalada (modo raw)', scaled_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None

*** 4. Cizallamiento (Shearing)
En el cizallamiento, los píxeles se desplazan en una dirección proporcional a otra, lo que inclina la imagen.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Crear una imagen vacía para el cizallamiento
sheared_img = np.zeros((x, y), dtype=np.uint8)

# Definir el factor de cizallamiento
shear_factor_x = 0.5

# Aplicar el cizallamiento en el eje x
for i in range(x):
    for j in range(y):
        new_x = i
        new_y = int(j + shear_factor_x * i)
        if 0 <= new_x < x and 0 <= new_y < y:
            sheared_img[new_x, new_y] = img[i, j]

# Mostrar la imagen original y la cizallada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Cizallada (modo raw)', sheared_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 5. Reflexión (Reflection)
La reflexión voltea la imagen sobre un eje, como el eje vertical o horizontal.

**** Reflexión horizontal
#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Crear una imagen vacía para la reflexión
reflected_img = np.zeros((x, y), dtype=np.uint8)

# Aplicar la reflexión horizontal
for i in range(x):
    for j in range(y):
        reflected_img[i, y - j - 1] = img[i, j]

# Mostrar la imagen original y la reflejada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Reflejada Horizontalmente (modo raw)', reflected_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

**** Reflexión vertical
#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Crear una imagen vacía para la reflexión
reflected_img = np.zeros((x, y), dtype=np.uint8)

# Aplicar la reflexión vertical
for i in range(x):
    for j in range(y):
        reflected_img[x - i - 1, j] = img[i, j]

# Mostrar la imagen original y la reflejada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Reflejada Verticalmente (modo raw)', reflected_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC


** Ejemplos de Transformaciones Geométricas en Python usando OpenCV

*** 1. Traslación
En OpenCV, la traslación se realiza usando matrices de transformación afín y la función `cv.warpAffine()`.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Definir el desplazamiento en x e y
dx, dy = 100, 50

# Crear la matriz de traslación
M = np.float32([[1, 0, dx], [0, 1, dy]])

# Aplicar la traslación usando warpAffine
translated_img = cv.warpAffine(img, M, (y, x))

# Mostrar la imagen original y la trasladada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Trasladada', translated_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 2. Rotación (alrededor del centro de la imagen)
La rotación alrededor del centro de la imagen se puede realizar con la función `cv.getRotationMatrix2D()`.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Calcular el centro de la imagen
center = (y // 2, x // 2)

# Definir el ángulo de rotación (en grados)
angle = 45

# Crear la matriz de rotación
M = cv.getRotationMatrix2D(center, angle, 1.0)

# Aplicar la rotación usando warpAffine
rotated_img = cv.warpAffine(img, M, (y, x))

# Mostrar la imagen original y la rotada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Rotada', rotated_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 3. Escalado
El escalado se puede realizar usando la función `cv.resize()`.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Definir el factor de escala
scale_x, scale_y = 0.5, 0.5

# Aplicar el escalado usando cv.resize()
scaled_img = cv.resize(img, None, fx=scale_x, fy=scale_y)

# Mostrar la imagen original y la escalada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Escalada', scaled_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None

*** 4. Cizallamiento (Shearing)
El cizallamiento se puede realizar creando una matriz de transformación afín personalizada.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Definir el factor de cizallamiento
shear_factor = 0.5

# Crear la matriz de cizallamiento
M = np.float32([[1, shear_factor, 0], [0, 1, 0]])

# Aplicar el cizallamiento usando warpAffine
sheared_img = cv.warpAffine(img, M, (y, x))

# Mostrar la imagen original y la cizallada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Cizallada', sheared_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 5. Reflexión (Reflection)
En OpenCV, la reflexión de una imagen se realiza con la función `cv.flip()`.

**** Reflexión horizontal
#+BEGIN_SRC python
import cv2 as cv

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Aplicar la reflexión horizontal usando cv.flip()
reflected_img = cv.flip(img, 1)

# Mostrar la imagen original y la reflejada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Reflejada Horizontalmente', reflected_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

**** Reflexión vertical
#+BEGIN_SRC python
import cv2 as cv

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Aplicar la reflexión vertical usando cv.flip()
reflected_img = cv.flip(img, 0)

# Mostrar la imagen original y la reflejada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Reflejada Verticalmente', reflected_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

** Primitivas de Dibujo

#+BEGIN_SRC python

import cv2 as cv
import numpy as np

img = np.ones((500, 500, 3), dtype=np.uint8)*255 
cv.circle(img, (250, 250), 50, (0,234,21), -1)
cv.circle(img, (250, 250), 30, (0,0,0), -1)

cv.line(img, (1,1), (230, 240), (0,234,21), 3   )
cv.rectangle(img, (20,20), (50,60), (0,0,0), 3 )
pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)
pts = pts.reshape((-1,1,2))
cv.polylines(img,[pts],True,(0,0,0), 3)
cv.imshow('img', img)
cv.waitKey()
cv.destroyAllWindows()



#+END_SRC

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

img = np.ones((500, 500), dtype=np.uint8)*255 

for i in range(50):
    cv.circle(img, (250+i, 250+i), 20+i, (0,234,21), -1)
    cv.imshow('img', img)
    #img = np.ones((500, 500, 3), dtype=np.uint8)*255 
    cv.waitKey(40)

cv.waitKey(0)
cv.destroyAllWindows()


#+END_SRC

#+RESULTS:
: None

** Parametricas

#+BEGIN_SRC python
import numpy as np
import cv2

# Función para generar un solo punto de la elipse en función del parámetro t
def generar_punto_elipse(a, b, t):
    x = int(a * 2* np.cos(t) + 200)  # Desplazamiento para centrar
    y = int(b * np.sin(t) + 200)
    return (x, y)

# Dimensiones de la imagen
img_width, img_height = 600, 600

# Crear una imagen en blanco
imagen = np.zeros((img_height, img_width, 3), dtype=np.uint8)

# Parámetros de la elipse
a = 200  # Semieje mayor
b = 100  # Semieje menor
num_puntos = 1000

# Crear los valores del parámetro t para la animación
t_vals = np.linspace(0, 2 * np.pi, num_puntos)

# Bucle de animación
for t in t_vals:
    # Crear una nueva imagen en blanco en cada iteración
    imagen = np.zeros((img_height, img_width, 3), dtype=np.uint8)
    
    # Generar el punto en la elipse
    punto = generar_punto_elipse(a, b, t)
    
    # Dibujar el punto en la elipse
    cv2.circle(imagen, punto, radius=, color=(0, 255, 0), thickness=-1)
    
    # Dibujar la trayectoria completa de la elipse (opcional, si quieres ver toda la elipse)
    for t_tray in t_vals:
        pt_tray = generar_punto_elipse(a, b, t_tray)
        cv2.circle(imagen, pt_tray, radius=1, color=(255, 255, 255), thickness=-1)
    
    # Mostrar la imagen con el punto en movimiento
    cv2.imshow('img', imagen)
    
    # Controlar la velocidad de la animación (en milisegundos)
    cv2.waitKey(10)

# Cerrar la ventana después de la animación
cv2.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None


#+BEGIN_SRC python
import numpy as np
import cv2

# Definir los parámetros de la circunferencia
r = 100  # radio
h = 250  # centro en x
k = 250  # centro en y
num_frames = 100  # número de frames en la animación
t_vals = np.linspace(0, 2*np.pi, num_frames)  # valores del parámetro t

# Crear una ventana para mostrar la animación
cv2.namedWindow('Animación Circunferencia', cv2.WINDOW_AUTOSIZE)

# Animar la circunferencia
for i in range(len(t_vals)):
    t = t_vals[i]
    
    # Calcular las coordenadas del punto en la circunferencia
    x = int(h + r * np.cos(t))
    y = int(k + r * np.sin(t))
    
    # Crear una imagen en blanco
    frame = np.ones((500, 500, 3), dtype=np.uint8) * 255
    
    # Dibujar la circunferencia
    cv2.circle(frame, (h, k), r, (0, 0, 0), 2)
    
    # Dibujar el punto en movimiento
    cv2.circle(frame, (x, y), 10, (0, 0, 255), -1)
    
    # Mostrar el frame en la ventana
    cv2.imshow('Animación Circunferencia', frame)
    
    # Esperar un corto tiempo para crear la animación (ajustar velocidad)
    cv2.waitKey(50)
    
# Cerrar la ventana cuando la animación termine
cv2.destroyAllWindows()

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python 
import numpy as np
import cv2


# Definir los parámetros iniciales
width, height = 1000, 1000  # Ampliar la ventana para ver toda la figura
img = np.ones((height, width, 3), dtype=np.uint8)*255

# Parámetros de la curva de Limacon
a, b = 150, 100  # Reducir los valores de a y b para que la curva se ajuste mejor
k = 10# Constante de multiplicación del ángulo
theta_increment = 0.05  # Incremento del ángulo
max_theta = 2 * np.pi  # Un ciclo completo

# Centro de la imagen
center_x, center_y = width // 2, height // 2

theta = 0  # Ángulo inicial

while True:  # Bucle infinito
    # Limpiar la imagen
    img = np.ones((width, height, 3), dtype=np.uint8) * 255
    
    # Dibujar la curva completa desde 0 hasta theta
    for t in np.arange(0, theta, theta_increment):
        # Calcular las coordenadas paramétricas (x, y) para la curva de Limacon
        r = a + b * np.cos(k * t)
        x = int(center_x + r * np.cos(t))
        y = int(center_y + r * np.sin(t))
        
        # Dibujar un círculo en la posición calculada
        cv2.circle(img, (x, y), 1, (0, 234, 0), 1)  # Color rojo
        cv2.circle(img, (x-2, y-2), 1, (0, 0, 0), 1)  # Color rojo
    
    # Mostrar la constante k en la imagen
    #cv2.putText(img, f"k = {k:.2f}", (20, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
    
    # Mostrar la imagen
    cv2.imshow("Parametric Animation", img)
    img = np.ones((width, height, 3), dtype=np.uint8) * 255
    
    # Incrementar el ángulo
    theta += theta_increment
    
    # Reiniciar theta si alcanza su valor máximo
    #if theta >= max_theta:
    #    theta = 0  # Reinicia la animación para que se repita

    # Pausar para ver la animación
    if cv2.waitKey(30) & 0xFF == 27:  # Esperar 30ms, salir con 'ESC'
        break

# Cerrar la ventana al finalizar
cv2.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None

** Segmentación de color mediante el modelo de color HSV

#+BEGIN_SRC python
import cv2 as cv

img = cv.imread('salida.png', 1)
hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
uba=(10, 255, 255)
ubb=(0, 40 ,40)
uba2=(180, 255, 255)
ubb2=(170, 40,40)
mask1 = cv.inRange(hsv, ubb, uba)
mask2 = cv.inRange(hsv, ubb2, uba2)
mask = mask1+mask2
#res = cv.bitwise_and(img, img, mask=mask)
x,y=mask.shape
for i in range(x):
    for j in range(y):
        if(mask[i,j]==0):
            mask[i,j]=150
        else:
            mask[i,j]=180
        cv.imshow('salida', mask)
        cv.waitKey(2)
#cv.imshow('mask1', mask1)
#cv.imshow('mask2', mask2)

#cv.imshow('res', res)
#cv.imshow('hsv', hsv )
#cv.imshow('img', img)

cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import cv2 as cv
import numpy as np
cap = cv.VideoCapture(0)

while(True):
    ret, img = cap.read()
    if ret:
        cv.imshow('video', img)
        hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
        uba=(90, 255, 255)
        ubb=(40, 40 ,40)
        mask = cv.inRange(hsv, ubb, uba)
        res = cv.bitwise_and(img, img, mask=mask)
        cv.imshow('res', res)
        
        k =cv.waitKey(1) & 0xFF
        if k == 27 :
	    break
    else:
        break
    
cap.release()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None











** Capa de Harry Potter
#+BEGIN_SRC python
import cv2
import numpy as np

# Captura de video desde la cámara
cap = cv2.VideoCapture(0)

# Permitir que la cámara se estabilice
cv2.waitKey(2000)

# Capturar el fondo durante unos segundos
ret, background = cap.read()
if not ret:
    print("Error al capturar el fondo.")
    cap.release()
    exit()

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    # Convertir el cuadro a espacio de color HSV
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

    # Definir el rango de color de la tela (verde, en este caso) en HSV
    lower_green = np.array([80, 180, 180])
    upper_green = np.array([145, 255, 255])

    # Crear una máscara que detecta el área verde
    mask = cv2.inRange(hsv, lower_green, upper_green)

    # Refinar la máscara (puedes ajustar los parámetros para mejorar la detección)

    # Invertir la máscara para obtener las áreas que no son verdes
    mask_inv = cv2.bitwise_not(mask)

    # Aplicar la máscara a la imagen original para mostrar solo las partes no verdes
    res1 = cv2.bitwise_and(frame, frame, mask=mask_inv)

    # Aplicar la máscara al fondo para cubrir las partes verdes
    res2 = cv2.bitwise_and(background, background, mask=mask)

    # Combinar ambas imágenes
    final_output = cv2.addWeighted(res1, 1, res2, 1, 0) 

    # Mostrar el resultado final
    cv2.imshow("Capa de Invisibilidad", final_output)
    cv2.imshow('mask', mask)

    # Presionar 'q' para salir
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Liberar los recursos
cap.release()
cv2.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None


** Efecto Gris np.where


La función *np.where* de NumPy es muy útil cuando se quiere
seleccionar elementos de un arreglo o imagen basado en una
condición. Vamos a desglosar cómo funciona y cómo se aplica en el
contexto de imágenes.

*** Sintaxis básica de np.where:

#+begin_src python :results output :exports both
np.where(condición, valor_si_verdadero, valor_si_falso)
#+end_src

- *condición*: Una expresión booleana (True/False) que indica qué elementos cumplen la condición.
- *valor_si_verdadero*: El valor que se asigna en las posiciones donde la condición es *True*.
- *valor_si_falso*: El valor que se asigna en las posiciones donde la condición es *False*.

**** Ejemplo sencillo:

#+begin_src python :results output :exports both
import numpy as np

# Creamos un array de ejemplo
array = np.array([1, 2, 3, 4, 5])

# Aplicamos np.where para cambiar los valores mayores a 3 por 100 y el resto por 0
resultado = np.where(array > 3, 100, 0)

print(resultado)  # Resultado: [  0   0   0 100 100]
#+end_src

En este ejemplo, la condición `array > 3` se cumple para los elementos 4 y 5, por lo que se cambian por 100, mientras que los otros elementos se cambian por 0.

*** Aplicación en procesamiento de imágenes:

Cuando manipulamos imágenes, cada pixel tiene tres valores (R, G,
B). La idea es usar `np.where` para verificar si un pixel cumple con
la condición de estar en el rango del color que queremos resaltar (por
ejemplo, rojo). Si el pixel está dentro de ese rango, conservamos el
valor original del color. Si no, convertimos ese pixel a escala de
grises.

**** Parte del código relevante:
#+begin_src python :results output :exports both
imagen_colores_resaltados = np.where(mascara_rojo[:, :, None] == 255, imagen, imagen_gris_bgr)
#+end_src

**** Desglose:

1. *`mascara_rojo[:, :, None] == 255`*:
   - La máscara es un arreglo 2D con los mismos altos y anchos que la
     imagen original, donde los valores son 255 para los pixeles que
     coinciden con el color rojo, y 0 para los que no.
   - *`[:, :, None]`*: Añade una tercera dimensión para que la máscara
     coincida con la estructura 3D de la imagen original, donde
     tenemos tres canales (R, G, B).
   - La condición `== 255` selecciona los píxeles donde el color rojo fue detectado.

2. *`imagen`*:
   - Es la imagen original en color. Se utiliza en las posiciones
     donde la máscara detecta el color rojo (condición `True`).

3. *`imagen_gris_bgr`*:
   - Es la versión de la imagen en escala de grises, convertida a
     formato BGR. Se usa en las posiciones donde la condición es
     `False`, es decir, donde no se detectó el color rojo.

**** Ejemplo visual:

Imagina que tienes un pixel con los siguientes valores RGB: `(255, 0,
0)` (un rojo intenso). Si este pixel cae dentro del rango de color
rojo, entonces `mascara_rojo` tendrá el valor 255 para ese pixel. Esto
hará que `np.where` conserve el pixel original en color:

- *Condición True (rojo detectado):* Se conserva el pixel original.
- *Condición False (no es rojo):* El pixel se convierte a su equivalente en escala de grises.

****y el  Ejemplo simplificado:
#+begin_src python :results output :exports both
# Si la máscara es:
mascara_rojo = [[255, 0], 
                [0, 255]]

# La imagen original en color (simplificada):
imagen = [[[255, 0, 0], [0, 255, 0]],
          [[0, 0, 255], [255, 0, 0]]]

# La imagen en gris (también simplificada):
imagen_gris_bgr = [[[128, 128, 128], [128, 128, 128]],
                   [[128, 128, 128], [128, 128, 128]]]

# Aplicando np.where:
resultado = np.where(mascara_rojo[:, :, None] == 255, imagen, imagen_gris_bgr)

# Resultado esperado:
resultado = [[[255, 0, 0], [128, 128, 128]],
             [[128, 128, 128], [255, 0, 0]]]
#+end_src

En el resultado, los pixeles que coinciden con el color rojo permanecen iguales, mientras que los otros se convierten a escala de grises.

**** ¿Cómo funciona esto para toda la imagen?

`np.where` revisa cada pixel de la imagen:

- **Si un pixel es rojo (según la máscara),** lo toma de la imagen original.
- **Si un pixel no es rojo,** lo toma de la versión en escala de grises.



- *np.where* actúa como un filtro condicional que selecciona valores en base a una máscara booleana.
- En este caso, se utiliza para dejar intactos los pixeles que coinciden con el color deseado (rojo) y convertir el resto de la imagen a escala de grises.



#+BEGIN_SRC python
import cv2
import numpy as np

# Leer la imagen en formato RGB
imagen = cv2.imread('man1.jpg', 1)
# Convertir la imagen de RGB a HSV
imagen_hsv = cv2.cvtColor(imagen, cv2.COLOR_BGR2HSV)
# Definir el rango de color rojo en HSV
bajo_rojo1 = np.array([0, 40, 40])
alto_rojo1 = np.array([10, 255, 255])
bajo_rojo2 = np.array([160, 40, 40])
alto_rojo2 = np.array([180, 255, 255])
# Crear una máscara para el color rojo
mascara_rojo1 = cv2.inRange(imagen_hsv, bajo_rojo1, alto_rojo1)
mascara_rojo2 = cv2.inRange(imagen_hsv, bajo_rojo2, alto_rojo2)
#mascara_rojo = mascara_rojo1 + mascara_rojo2
mascara_rojo = cv2.add(mascara_rojo1, mascara_rojo2)
# Convertir la imagen original a escala de grises
imagen_gris = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
# Convertir la imagen gris a un formato BGR para que coincida con la original
imagen_gris_bgr = cv2.cvtColor(imagen_gris, cv2.COLOR_GRAY2BGR)
# Combinar la imagen en gris con las áreas en rojo
resultado = np.where(mascara_rojo[:, :, None] == 255, imagen, imagen_gris_bgr)
# Mostrar la imagen final
cv2.imshow('Color resaltado', resultado)
cv2.imshow('mascara_rojo', mascara_rojo)
cv2.imshow('imagen', imagen)
cv2.imshow('imagen_gris__bgr', imagen_gris_bgr)
cv2.waitKey(0)
cv2.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None


#+BEGIN_SRC python
import cv2 as cv
import numpy as np
cap = cv.VideoCapture(0)

while(True):
    ret, imagen = cap.read()
    if ret:
        cv.imshow('video', imagen)
        imagen_hsv = cv.cvtColor(imagen, cv.COLOR_BGR2HSV)
        bajo_azul1 = np.array([100, 40, 40])
        alto_azul1 = np.array([140, 255, 255])
      
        # Crear una máscara para el color rojo
        mascara_azul1 = cv.inRange(imagen_hsv, bajo_azul1, alto_azul1)
      
        # Convertir la imagen original a escala de grises
        imagen_gris = cv.cvtColor(imagen, cv.COLOR_BGR2GRAY)

        # Convertir la imagen gris a un formato BGR para que coincida con la original
        imagen_gris_bgr = cv.cvtColor(imagen_gris, cv.COLOR_GRAY2BGR)

        # Combinar la imagen en gris con las áreas en rojo
        resultado = np.where(mascara_azul1[:, :, None] == 255, imagen, imagen_gris_bgr)

        # Mostrar la imagen final
        cv.imshow('Color resaltado', resultado)
        
        k =cv.waitKey(1) & 0xFF
        if k == 27 :
	    break
    else:
        break
    
cap.release()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None


** Flujo optico

#+BEGIN_SRC python

import numpy as np
import cv2 as cv

# Iniciar la captura de video desde la cámara
cap = cv.VideoCapture(0)

# Parámetros para el flujo óptico Lucas-Kanade
lk_params = dict(winSize=(15, 15), maxLevel=2,
                 criteria=(cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 10, 0.03))

# Leer el primer frame de la cámara
ret, first_frame = cap.read()
prev_gray = cv.cvtColor(first_frame, cv.COLOR_BGR2GRAY)

# Posición inicial de la pelotita (un único punto en el centro de la imagen)
ball_pos = np.array([[500, 500]], dtype=np.float32)
ball_pos = ball_pos[:, np.newaxis, :]

while True:
    # Capturar el siguiente frame
    ret, frame = cap.read()
    if not ret:
        break

    x, y =frame.shape[:2]
    frame= cv.flip(frame,1)
    # Convertir el frame a escala de grises
    gray_frame = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)

    # Calcular el flujo óptico para mover la pelotita
    new_ball_pos, st, err = cv.calcOpticalFlowPyrLK(prev_gray, gray_frame, ball_pos, None, **lk_params)

    # Si se detecta el nuevo movimiento, actualizar la posición de la pelotita
    if new_ball_pos is not None:
        ball_pos = new_ball_pos

        # Dibujar la pelotita en su nueva posición
        a, b = ball_pos.ravel()
        frame = cv.circle(frame, (int(a), int(b)), 20, (0, 255, 0), -1)
    cv.rectangle(frame, (20,20), (y-20, x-20), (234,43 ,34) ,5)    
    # Mostrar solo una ventana con la pelotita en movimiento
    cv.imshow('Pelota en movimiento', frame)

    # Actualizar el frame anterior para el siguiente cálculo
    prev_gray = gray_frame.copy()

    # Presionar 'Esc' para salir
    if cv.waitKey(30) & 0xFF == 27:
        break

# Liberar la captura y destruir todas las ventanas
cap.release()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None


#+BEGIN_SRC python :results output
import numpy as np 
import cv2 as cv

cap = cv.VideoCapture(0)


lkparm =dict(winSize=(15,15), maxLevel=2,
             criteria=(cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 10, 0.03)) 


_, vframe = cap.read()
vgris = cv.cvtColor(vframe, cv.COLOR_BGR2GRAY)
p0 = np.array([(100,100), (300,100), (300,100), (400,100), (500,100),
               (100,200), (200,200), (300,200), (400,200), (500,200),
               (100,300), (200,300), (300,300), (400,300), (500,300),
               (100,400), (200,400), (300,400), (400,400), (500,400)])

p0 = np.float32(p0[:, np.newaxis, :])

mask = np.zeros_like(vframe) 
cad =''

while True:
    _, frame = cap.read()
    fgris = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    p1, st, err = cv.calcOpticalFlowPyrLK(vgris, fgris, p0, None, **lkparm) 

    if p1 is None:
        vgris = cv.cvtColor(vframe, cv.COLOR_BGR2GRAY)
        p0 = np.array([(100,100), (200,100), (300,100), (400,100) ])
        p0 = np.float32(p0[:, np.newaxis, :])
        mask = np.zeros_like(vframe)
        cv.imshow('ventana', frame)
    else:
        bp1 = p1[st ==1]
        bp0 = p0[st ==1]
        
        for i, (nv, vj) in enumerate(zip(bp1, bp0)):
            a, b = (int(x) for x in nv.ravel())
            c, d = (int(x) for x in vj.ravel())
            dist = np.linalg.norm(nv.ravel() - vj.ravel())

            #print(i, dist)
            
            
            
            frame = cv.line(frame, (c,d), (a,b), (0,0,255), 2)
            frame = cv.circle(frame, (c,d), 2, (255,0,0),-1)
            frame = cv.circle(frame, (a,b), 3, (0,255,0),-1)
        cv.imshow('ventana', frame)

        vgris = fgris.copy()

        if(cv.waitKey(1) & 0xff) == 27:
            break

cap.release()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:


** Ejemplo de clasificación utilizando Haarcascades 
	
	- [[https://github.com/opencv/opencv/tree/master/data/haarcascades][Clasificadores Haarcascades de la librería Opencv]]
	- [[https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html][Tutorial Haarcascades]]  
	- [[https://docs.opencv.org/2.4/doc/user_guide/ug_traincascade.html][Entrenamiento Haarcascades]]  


#+BEGIN_SRC python
import numpy as np
import cv2 as cv

rostro = cv.CascadeClassifier('haarcascade_frontalface_alt2.xml')
cap = cv.VideoCapture(0)
x=y=w=h= 0 
count = 0
while True:
    ret, frame = cap.read()
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    rostros = rostro.detectMultiScale(gray, 1.3, 5)
    for(x, y, w, h) in rostros:
        m= int(h/2)
        frame = cv.rectangle(frame, (x,y), (x+w, y+h), (0, 255, 0), 2)
        #frame = cv.rectangle(frame, (x,y+m), (x+w, y+h), (255, 0 ,0), 2 )
        #img = 180- frame[y:y+h,x:x+w]
        #count = count + 1   
    
    #name = '/home/likcos/imgs/cara'+str(count)+'.jpg'
    #cv.imwrite(name, frame)
    cv.imshow('rostros', frame)
    #cv.imshow('cara', img)
    
    k = cv.waitKey(1)
    if k == 27:
        break
cap.release()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None


#+BEGIN_SRC python
import cv2 as cv 

rostro = cv.CascadeClassifier('haarcascade_frontalface_alt.xml')
cap = cv.VideoCapture(0)

while True:
    ret, img = cap.read()
    gris = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    rostros = rostro.detectMultiScale(gris, 1.3, 5)
    for(x,y,w,h) in rostros:
        res = int((w+h)/8)
        img = cv.rectangle(img, (x,y), (x+w, y+h), (234, 23,23), 5)
        #img = cv.rectangle(img, (x,int(y+h/2)), (x+w, y+h), (0,255,0),5 )
        img = cv.circle(img, (x + int(w*0.3), y + int(h*0.4)) , 21, (0, 0, 0), 2 )
        img = cv.circle(img, (x + int(w*0.7), y + int(h*0.4)) , 21, (0, 0, 0), 2 )
        img = cv.circle(img, (x + int(w*0.3), y + int(h*0.4)) , 20, (255, 255, 255), -1 )
        img = cv.circle(img, (x + int(w*0.7), y + int(h*0.4)) , 20, (255, 255, 255), -1 )
        img = cv.circle(img, (x + int(w*0.3), y + int(h*0.4)) , 5, (0, 0, 255), -1 )
        img = cv.circle(img, (x + int(w*0.7), y + int(h*0.4)) , 5, (0, 0, 255), -1 )

    cv.imshow('img', img)
    if cv.waitKey(1)== ord('q'):
        break
    
cap.release
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None


#+begin_src python
import cv2
import numpy as np

# Cargar la máscara que deseas agregar (asegúrate de que sea PNG con transparencia)
mascara = cv2.imread('cubre3.png', cv2.IMREAD_UNCHANGED)  # Cargar PNG con transparencia

# Verificar si la imagen tiene un canal alfa
if mascara.shape[2] != 4:
    print("Error: La imagen no tiene canal alfa.")
    exit()

# Cargar el clasificador preentrenado de rostros
face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_alt2.xml')

# Capturar video desde la cámara
video = cv2.VideoCapture(0)

# Definir un desplazamiento para mover la máscara
desplazamiento_x = -100  # Mover 50 píxeles hacia la derecha
desplazamiento_y = 90  # Mover 30 píxeles hacia arriba

while True:
    # Leer cada frame del video
    ret, frame = video.read()

    if not ret:
        break

    # Convertir el frame a escala de grises
    frame_gris = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Detectar los rostros en el frame
    rostros = face_cascade.detectMultiScale(frame_gris, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

    # Procesar cada rostro detectado
    for (x, y, w, h) in rostros:
        # Redimensionar la máscara para que coincida con el tamaño del rostro detectado
        mascara_redimensionada = cv2.resize(mascara, (w, h))
        cv2.rectangle(frame, (x,y), (x+w, y+h), (255, 0,0), 3)
        # Separar los canales de la máscara: color y alfa (transparencia)
        mascara_rgb = mascara_redimensionada[:, :, :3]
        mascara_alpha = mascara_redimensionada[:, :, 3]

        # Asegurarse de que la máscara alfa sea de tipo uint8
        mascara_alpha = cv2.convertScaleAbs(mascara_alpha)

        # Aplicar el desplazamiento a las coordenadas x e y
        x_nuevo = x + desplazamiento_x
        y_nuevo = y + desplazamiento_y

        # Evitar que la máscara salga del borde de la imagen
        if x_nuevo < 0: x_nuevo = 0
        if y_nuevo < 0: y_nuevo = 0
        if x_nuevo + w > frame.shape[1]: x_nuevo = frame.shape[1] - w
        if y_nuevo + h > frame.shape[0]: y_nuevo = frame.shape[0] - h

        # Crear una región de interés (ROI) en el frame donde colocaremos la máscara
        roi = frame[y_nuevo:y_nuevo+h, x_nuevo:x_nuevo+w]

        # Asegurarse de que la ROI y la máscara tengan el mismo tamaño
        if roi.shape[:2] == mascara_alpha.shape[:2]:
            # Invertir la máscara alfa para obtener la parte del rostro donde se aplicará la máscara
            mascara_alpha_inv = cv2.bitwise_not(mascara_alpha)

            # Enmascarar la región del rostro en la imagen original
            fondo = cv2.bitwise_and(roi, roi, mask=mascara_alpha_inv)

            # Enmascarar la máscara RGB
            mascara_fg = cv2.bitwise_and(mascara_rgb, mascara_rgb, mask=mascara_alpha)

            # Combinar el fondo (parte del rostro sin máscara) y la parte con la máscara
            resultado = cv2.add(fondo, mascara_fg)

            # Reemplazar la región del rostro con la imagen combinada
            frame[y_nuevo:y_nuevo+h, x_nuevo:x_nuevo+w] = resultado

        else:
            print("Error: El tamaño de la ROI no coincide con la máscara.")

    # Mostrar el frame con la máscara aplicada
    cv2.imshow('Video con mascara', frame)

    # Presionar 'q' para salir del loop
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Liberar la captura de video y cerrar las ventanas
video.release()
cv2.destroyAllWindows()

#+end_src

#+RESULTS:
: None


** OpenGL



** Descripción de la Proyección Isométrica
La proyección isométrica es un tipo de proyección axonométrica que
representa un objeto 3D en un espacio 2D sin perspectiva. Esto
significa que las líneas paralelas en el espacio 3D siguen siendo
paralelas en la proyección 2D, y los objetos mantienen la misma escala
independientemente de su distancia. En una proyección isométrica, los
tres ejes (x, y, z) aparecen con ángulos de 120° entre sí, creando un
efecto visual que se percibe como 3D, aunque solo se trata de una
imagen 2D.

Este tipo de proyección es útil en videojuegos, gráficos isométricos y
aplicaciones de diseño, ya que proporciona una representación en 3D
simple sin distorsión de perspectiva.


*** Ejemplo de Proyección Isométrica en OpenCV

Este ejemplo en OpenCV muestra cómo proyectar un cubo 3D en 2D
utilizando una proyección isométrica. Cada vértice del cubo se
proyecta en el plano 2D, y luego se conecta para formar las aristas
del cubo.

**** Código en Python

#+BEGIN_SRC python
import cv2
import numpy as np
import math

# Dimensiones de la ventana
WIDTH, HEIGHT = 800, 600

# Vértices del cubo en coordenadas 3D
vertices = np.array([
    [-1, -1, -1],
    [1, -1, -1],
    [1, 1, -1],
    [-1, 1, -1],
    [-1, -1, 1],
    [1, -1, 1],
    [1, 1, 1],
    [-1, 1, 1]
])

# Conexiones de los vértices para formar las aristas del cubo
edges = [
    (0, 1), (1, 2), (2, 3), (3, 0),  # Base inferior
    (4, 5), (5, 6), (6, 7), (7, 4),  # Base superior
    (0, 4), (1, 5), (2, 6), (3, 7)   # Conexiones entre bases
]

def project_isometric(vertex):
    """Función para proyectar un punto 3D a 2D con proyección isométrica"""
    x, y, z = vertex
    x2D = x - z
    y2D = (x + 2 * y + z) / 2
    return int(x2D * 100 + WIDTH / 2), int(-y2D * 100 + HEIGHT / 2)

# Crear ventana
cv2.namedWindow("Cubo Isométrico")

while True:
    # Crear imagen negra para el fondo
    frame = np.zeros((HEIGHT, WIDTH, 3), dtype=np.uint8)

    # Dibujar aristas del cubo
    for edge in edges:
        pt1 = project_isometric(vertices[edge[0]])
        pt2 = project_isometric(vertices[edge[1]])
        cv2.line(frame, pt1, pt2, (255, 255, 255), 2)

    # Mostrar imagen
    cv2.imshow("Cubo Isométrico", frame)

    # Salir si se presiona 'q'
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cv2.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None

**** Explicación del Código
1. **Definición de Vértices y Aristas**:
   - `vertices` define los puntos 3D del cubo en coordenadas `(x, y, z)`.
   - `edges` define las conexiones entre los vértices para formar las aristas del cubo.

2. **Función `project_isometric`**:
   - Convierte cada vértice 3D en coordenadas 2D usando una proyección isométrica. La fórmula aplicada crea un efecto 3D sin perspectiva.

3. **Bucle de Renderizado**:
   - Cada fotograma crea una imagen de fondo negro (`frame`) y dibuja las aristas del cubo conectando los puntos proyectados en 2D.
   - El bucle continúa hasta que se presiona la tecla `'q'`.

**** Salida Esperada
La ventana mostrará un cubo en perspectiva isométrica. Las aristas se
dibujan en blanco y el cubo parece tener profundidad, aunque es solo
una representación en 2D.

Este ejemplo simula un efecto 3D mediante una proyección isométrica,
útil para aplicaciones de diseño y gráficos 2D en OpenCV.


** Opengl Ejemplo

#+begin_src python
import glfw
from OpenGL.GL import glClear, glClearColor, glBegin, GL_QUADS, glEnd, glVertex2f, glColor3f, GL_COLOR_BUFFER_BIT, GL_TRIANGLES

def main():
    # Inicializar GLFW
    if not glfw.init():
        return

    # Crear la ventana
    window = glfw.create_window(500, 500, "OpenGL con GLFW", None, None)
    if not window:
        glfw.terminate()
        return

    # Hacer el contexto de OpenGL actual
    glfw.make_context_current(window)

    # Establecer el color de fondo
    glClearColor(0.0, 0.0, 0.0, 1.0)

    # Bucle principal de renderizado
    while not glfw.window_should_close(window):
        # Limpiar la pantalla
        glClear(GL_COLOR_BUFFER_BIT)

        # Dibujar un triángulo
        glBegin(GL_TRIANGLES)
        glColor3f(1.0, 0.0, 0.0)  # Rojo
        glVertex2f(-0.5,  -0.5)  # Vértice superior izquierdo
        glColor3f(0.0, 1.0, 0.0)  # Rojo
        glColor3f(0.0, 1.0, 0.0)  # Rojo
        glVertex2f( 0.5,  -0.5)  # Vértice superior derecho
        glColor3f(0.0, 0.0, 1.0)  # Rojo
        glVertex2f( -0.5, 0.5)  # Vértice inferior derecho
        
        glEnd()

        # Intercambiar buffers y procesar eventos
        glfw.swap_buffers(window)
        glfw.poll_events()

    # Terminar GLFW
    glfw.terminate()

if __name__ == "__main__":
    main()

#+end_src

#+RESULTS:
: None


#+BEGIN_SRC python
import glfw
from OpenGL.GL import glClear, glClearColor, glBegin, glEnd, glVertex2f, glColor3f, GL_COLOR_BUFFER_BIT, GL_QUADS, glOrtho

def draw_square():
    glBegin(GL_QUADS)
    glColor3f(1.0, 0.0, 0.0)  # Color rojo
    glVertex2f(-0.5,  0.5)  # Vértice superior izquierdo
    glVertex2f( 0.5,  0.5)  # Vértice superior derecho
    glVertex2f( 0.5, -0.5)  # Vértice inferior derecho
    glVertex2f(-0.5, -0.5)  # Vértice inferior izquierdo
    glEnd()

def main():
    # Inicializar GLFW
    if not glfw.init():
        return

    # Crear la ventana con un contexto de OpenGL
    window = glfw.create_window(500, 500, "Cuadrado con GLFW", None, None)
    if not window:
        glfw.terminate()
        return

    # Hacer que el contexto de OpenGL sea actual para la ventana
    glfw.make_context_current(window)

    # Configurar la proyección ortográfica
    glOrtho(-1, 1, -1, 1, -1, 1)  # Configuración para un sistema de coordenadas 2D

    # Bucle principal
    while not glfw.window_should_close(window):
        # Limpiar el buffer de color
        glClear(GL_COLOR_BUFFER_BIT)

        # Dibujar el cuadrado
        draw_square()

        # Intercambiar buffers y procesar eventos
        glfw.swap_buffers(window)
        glfw.poll_events()

    # Terminar GLFW
    glfw.terminate()

if __name__ == "__main__":
    main()


#+END_SRC

#+RESULTS:
: None


* Introducción a OpenGL

OpenGL (Open Graphics Library) es una API de gráficos que permite a
los desarrolladores crear gráficos en 2D y 3D. Fue desarrollada por
Silicon Graphics en 1992 y, desde entonces, se ha utilizado
ampliamente en aplicaciones que requieren renderizado en tiempo real,
como videojuegos, simulaciones científicas, visualización de datos y
entornos de realidad virtual y aumentada.

** Características de OpenGL
   - **Plataforma abierta**: OpenGL es multiplataforma y funciona en
     Windows, macOS, y Linux.
   - **API de bajo nivel**: Proporciona primitivas de gráficos básicas
     (puntos, líneas, polígonos).
   - **Hardware acelerado**: Aprovecha la GPU para acelerar el
     renderizado.
   - **Flexibilidad**: Es compatible con diversas aplicaciones, desde
     gráficos simples en 2D hasta gráficos avanzados en 3D.

** Primeros pasos en OpenGL
Para empezar a trabajar con OpenGL, necesitas entender algunos de sus
conceptos y configuraciones básicas.

*** Configuración del Entorno
Para utilizar OpenGL en Python, necesitas instalar las siguientes
bibliotecas:
#+begin_src shell
  pip install PyOpenGL PyOpenGL_accelerate glfw pygames
  pip install PyOpenGL glfw
#+end_src

*** Estructura básica de un programa OpenGL
Un programa básico de OpenGL tiene una estructura general que incluye
la configuración de la ventana, la inicialización del contexto de
OpenGL, el renderizado de objetos y el bucle principal.

** Sistema de Coordenadas en OpenGL
En OpenGL, las coordenadas pasan por una serie de transformaciones
para dibujar objetos en pantalla. Aquí están los principales sistemas
de coordenadas:

*** Coordenadas del Objeto
   Este es el espacio de coordenadas local de cada objeto. Aquí
   defines los vértices en relación con el centro del objeto.

*** Coordenadas del Mundo
   Transforman las coordenadas del objeto para situarlo en el mundo virtual.

*** Coordenadas de Vista
   Ajustan la posición del objeto en relación con la cámara u observador.

*** Coordenadas de Recorte
   Aplican la proyección para determinar qué partes del objeto son
   visibles y cuáles están fuera del campo de visión.

*** Coordenadas Normalizadas del Dispositivo (NDC)
   Las coordenadas se normalizan al rango [-1, 1] en cada eje, para
   definir la porción visible de la escena.

*** Coordenadas de Pantalla
   Las coordenadas normalizadas se mapean a píxeles en la pantalla
   según la resolución de la ventana.

** Primitivas de Dibujo en OpenGL
OpenGL permite dibujar figuras básicas conocidas como primitivas,
entre las que se incluyen:

   - **GL_POINTS**: Puntos individuales.
   - **GL_LINES**: Líneas entre pares de vértices.
   - **GL_TRIANGLES**: Triángulos entre grupos de tres vértices.
   - **GL_QUADS**: Cuadrados entre grupos de cuatro vértices (obsoleto en OpenGL moderno).

Ejemplo de uso de **GL_TRIANGLES** para dibujar un triángulo:

#+begin_src python
  import glfw
  from OpenGL.GL import *
  from OpenGL.GLU import *

  def draw_triangle():
      glBegin(GL_TRIANGLES)
      glColor3f(1.0, 0.0, 0.0)  # Rojo
      glVertex2f(-0.5, -0.5)    # Vértice inferior izquierdo
      glColor3f(0.0, 1.0, 0.0)  # Verde
      glVertex2f(0.5, -0.5)     # Vértice inferior derecho
      glColor3f(0.0, 0.0, 1.0)  # Azul
      glVertex2f(0.0, 0.5)      # Vértice superior
      glEnd()
#+end_src

#+RESULTS:


#+BEGIN_SRC python :results output :tangle code/cubo.py
import glfw
from OpenGL.GL import glClearColor, glEnable, glClear, glLoadIdentity, glTranslatef, glRotatef, glMatrixMode
from OpenGL.GL import glBegin, glColor3f, glVertex3f, glEnd, glFlush, glViewport
from OpenGL.GL import GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_DEPTH_TEST, GL_QUADS, GL_PROJECTION, GL_MODELVIEW
from OpenGL.GLU import gluPerspective
import sys

# Variables globales
window = None
angle = 0  # Declaramos angle en el nivel superior

def init():
    # Configuración inicial de OpenGL
    glClearColor(0.0, 0.0, 0.0, 1.0)  # Color de fondo
    glEnable(GL_DEPTH_TEST)  # Activar prueba de profundidad para 3D

    # Configuración de proyección
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45, 1.0, 0.1, 50.0)

    # Cambiar a la matriz de modelo para los objetos
    glMatrixMode(GL_MODELVIEW)

def draw_cube():
    global angle
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)  # Limpiar pantalla y buffer de profundidad

    # Configuración de la vista del cubo
    glLoadIdentity()
    glTranslatef(0.0, 0.0, -5)  # Alejar el cubo para que sea visible
    glRotatef(angle, 0, 0,1)   # Rotar el cubo en todos los ejes

    glBegin(GL_QUADS)  # Iniciar el cubo como un conjunto de caras (quads)

    # Cada conjunto de cuatro vértices representa una cara del cubo
    glColor3f(1.0, 0.0, 0.0)  # Rojo
    glVertex3f( 1, 1,-1)
    glVertex3f(-1, 1,-1)
    glVertex3f(-1, 1, 1)
    glVertex3f( 1, 1, 1)

    glColor3f(0.0, 1.0, 0.0)  # Verde
    glVertex3f( 1,-1, 1)
    glVertex3f(-1,-1, 1)
    glVertex3f(-1,-1,-1)
    glVertex3f( 1,-1,-1)

    glColor3f(0.0, 0.0, 1.0)  # Azul
    glVertex3f( 1, 1, 1)
    glVertex3f(-1, 1, 1)
    glVertex3f(-1,-1, 1)
    glVertex3f( 1,-1, 1)

    glColor3f(1.0, 1.0, 0.0)  # Amarillo
    glVertex3f( 1,-1,-1)
    glVertex3f(-1,-1,-1)
    glVertex3f(-1, 1,-1)
    glVertex3f( 1, 1,-1)

    glColor3f(1.0, 0.0, 1.0)  # Magenta
    glVertex3f(-1, 1, 1)
    glVertex3f(-1, 1,-1)
    glVertex3f(-1,-1,-1)
    glVertex3f(-1,-1, 1)

    glColor3f(0.0, 1.0, 1.0)  # Cyan
    glVertex3f( 1, 1,-1)
    glVertex3f( 1, 1, 1)
    glVertex3f( 1,-1, 1)
    glVertex3f( 1,-1,-1)

    glEnd()
    glFlush()

    glfw.swap_buffers(window)  # Intercambiar buffers para animación suave
    angle += 1  # Incrementar el ángulo para rotación

def main():
    global window

    # Inicializar GLFW
    if not glfw.init():
        sys.exit()

    # Crear ventana de GLFW
    width, height = 500, 500
    window = glfw.create_window(width, height, "Cubo 3D Rotando con GLFW", None, None)
    if not window:
        glfw.terminate()
        sys.exit()

    # Configurar el contexto de OpenGL en la ventana
    glfw.make_context_current(window)

    # Configuración de viewport y OpenGL
    glViewport(0, 0, width, height)
    init()

    # Bucle principal
    while not glfw.window_should_close(window):
        draw_cube()
        glfw.poll_events()

    glfw.terminate()  # Cerrar GLFW al salir

if __name__ == "__main__":
    main()

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results output :tangle code/cuboraton.py
import glfw
from OpenGL.GL import glClearColor, glEnable, glClear, glLoadIdentity, glTranslatef, glRotatef, glMatrixMode
from OpenGL.GL import glBegin, glColor3f, glVertex3f, glEnd, glFlush, glViewport
from OpenGL.GL import GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_DEPTH_TEST, GL_QUADS, GL_PROJECTION, GL_MODELVIEW
from OpenGL.GLU import gluPerspective
import sys

# Variables globales
window = None
angle_x, angle_y = 0, 0  # Ángulos de rotación en los ejes X e Y
last_x, last_y = None, None  # Última posición del ratón para calcular la diferencia

def init():
    # Configuración inicial de OpenGL
    glClearColor(0.0, 0.0, 0.0, 1.0)  # Color de fondo
    glEnable(GL_DEPTH_TEST)  # Activar prueba de profundidad para 3D

    # Configuración de proyección
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45, 1.0, 0.1, 50.0)

    # Cambiar a la matriz de modelo para los objetos
    glMatrixMode(GL_MODELVIEW)

def draw_cube():
    global angle_x, angle_y
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)  # Limpiar pantalla y buffer de profundidad

    # Configuración de la vista del cubo
    glLoadIdentity()
    glTranslatef(0.0, 0.0, -5)  # Alejar el cubo para que sea visible
    glRotatef(angle_x, 1, 0, 0)   # Rotar el cubo en el eje X
    glRotatef(angle_y, 0, 1, 0)   # Rotar el cubo en el eje Y

    glBegin(GL_QUADS)  # Iniciar el cubo como un conjunto de caras (quads)

    # Cada conjunto de cuatro vértices representa una cara del cubo
    glColor3f(1.0, 0.0, 0.0)  # Rojo
    glVertex3f( 1, 1,-1)
    glVertex3f(-1, 1,-1)
    glVertex3f(-1, 1, 1)
    glVertex3f( 1, 1, 1)

    glColor3f(0.0, 1.0, 0.0)  # Verde
    glVertex3f( 1,-1, 1)
    glVertex3f(-1,-1, 1)
    glVertex3f(-1,-1,-1)
    glVertex3f( 1,-1,-1)

    glColor3f(0.0, 0.0, 1.0)  # Azul
    glVertex3f( 1, 1, 1)
    glVertex3f(-1, 1, 1)
    glVertex3f(-1,-1, 1)
    glVertex3f( 1,-1, 1)

    glColor3f(1.0, 1.0, 0.0)  # Amarillo
    glVertex3f( 1,-1,-1)
    glVertex3f(-1,-1,-1)
    glVertex3f(-1, 1,-1)
    glVertex3f( 1, 1,-1)

    glColor3f(1.0, 0.0, 1.0)  # Magenta
    glVertex3f(-1, 1, 1)
    glVertex3f(-1, 1,-1)
    glVertex3f(-1,-1,-1)
    glVertex3f(-1,-1, 1)

    glColor3f(0.0, 1.0, 1.0)  # Cyan
    glVertex3f( 1, 1,-1)
    glVertex3f( 1, 1, 1)
    glVertex3f( 1,-1, 1)
    glVertex3f( 1,-1,-1)

    glEnd()
    glFlush()

    glfw.swap_buffers(window)  # Intercambiar buffers para animación suave

def mouse_callback(window, xpos, ypos):
    global angle_x, angle_y, last_x, last_y

    # Si es la primera vez que movemos el ratón, inicializamos last_x y last_y
    if last_x is None or last_y is None:
        last_x, last_y = xpos, ypos

    # Calcular las diferencias en el movimiento del ratón
    dx = xpos - last_x
    dy = ypos - last_y

    # Ajustar los ángulos de rotación en función del movimiento del ratón
    angle_x += dy * 0.1  # El factor 0.1 ajusta la sensibilidad
    angle_y += dx * 0.1

    # Actualizar las posiciones anteriores del ratón
    last_x, last_y = xpos, ypos

def main():
    global window

    # Inicializar GLFW
    if not glfw.init():
        sys.exit()

    # Crear ventana de GLFW
    width, height = 500, 500
    window = glfw.create_window(width, height, "Cubo 3D Controlado por Ratón", None, None)
    if not window:
        glfw.terminate()
        sys.exit()

    # Configurar el contexto de OpenGL en la ventana
    glfw.make_context_current(window)
    glViewport(0, 0, width, height)
    init()

    # Configurar el callback de ratón
    glfw.set_cursor_pos_callback(window, mouse_callback)

    # Bucle principal
    while not glfw.window_should_close(window):
        draw_cube()
        glfw.poll_events()

    glfw.terminate()  # Cerrar GLFW al salir

if __name__ == "__main__":
    main()


#+END_SRC


#+RESULTS:


#+BEGIN_SRC python :results output :tangle code/toroide.py
import glfw
from OpenGL.GL import *
from OpenGL.GLU import gluPerspective
import numpy as np
import sys

# Variables globales para el ángulo de rotación
window = None
angle_x, angle_y = 0.0, 0.0  # Ángulos de rotación en los ejes X e Y
last_x, last_y = None, None  # Última posición del ratón para calcular la diferencia

# Parámetros del toroide
R = 1.0  # Radio mayor (distancia del centro del tubo al centro del toroide)
r = 0.4  # Radio menor (radio del tubo)
num_major = 30  # Segmentos en el círculo mayor
num_minor = 15  # Segmentos en el círculo menor

def init():
    # Configuración inicial de OpenGL
    glClearColor(0.0, 0.0, 0.0, 1.0)  # Color de fondo
    glEnable(GL_DEPTH_TEST)  # Activar prueba de profundidad para 3D

    # Configuración de proyección
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45, 1.0, 0.1, 50.0)

    # Cambiar a la matriz de modelo para los objetos
    glMatrixMode(GL_MODELVIEW)

def draw_torus():
    global angle_x, angle_y
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)  # Limpiar pantalla y buffer de profundidad

    # Configuración de la vista del toroide
    glLoadIdentity()
    glTranslatef(0.0, 0.0, -5)  # Alejar el toroide para que sea visible
    glRotatef(angle_x, 1, 0, 0)   # Rotar el toroide en el eje X
    glRotatef(angle_y, 0, 1, 0)   # Rotar el toroide en el eje Y

    # Dibujar el toroide utilizando segmentos
    for i in range(num_major):
        theta = 2 * np.pi * i / num_major
        next_theta = 2 * np.pi * (i + 1) / num_major

        glBegin(GL_QUAD_STRIP)
        for j in range(num_minor + 1):
            phi = 2 * np.pi * j / num_minor
            cos_theta, sin_theta = np.cos(theta), np.sin(theta)
            cos_next_theta, sin_next_theta = np.cos(next_theta), np.sin(next_theta)
            cos_phi, sin_phi = np.cos(phi), np.sin(phi)

            # Color dinámico para variación visual
            glColor3f((i % 2) * 0.5 + 0.5, (j % 2) * 0.5 + 0.5, 0.5)

            # Primera esquina
            x = (R + r * cos_phi) * cos_theta
            y = r * sin_phi
            z = (R + r * cos_phi) * sin_theta
            glVertex3f(x, y, z)

            # Segunda esquina
            x = (R + r * cos_phi) * cos_next_theta
            z = (R + r * cos_phi) * sin_next_theta
            glVertex3f(x, y, z)

        glEnd()

    glfw.swap_buffers(window)  # Intercambiar buffers para animación suave

def mouse_callback(window, xpos, ypos):
    global angle_x, angle_y, last_x, last_y

    # Si es la primera vez que movemos el ratón, inicializamos last_x y last_y
    if last_x is None or last_y is None:
        last_x, last_y = xpos, ypos

    # Calcular las diferencias en el movimiento del ratón
    dx = xpos - last_x
    dy = ypos - last_y

    # Ajustar los ángulos de rotación en función del movimiento del ratón
    angle_x += dy * 0.2  # Factor de sensibilidad en Y
    angle_y += dx * 0.2  # Factor de sensibilidad en X

    # Actualizar las posiciones anteriores del ratón
    last_x, last_y = xpos, ypos

def main():
    global window

    # Inicializar GLFW
    if not glfw.init():
        sys.exit()

    # Crear ventana de GLFW
    width, height = 500, 500
    window = glfw.create_window(width, height, "Toroide 3D Controlado por Ratón", None, None)
    if not window:
        glfw.terminate()
        sys.exit()

    # Configurar el contexto de OpenGL en la ventana
    glfw.make_context_current(window)
    glViewport(0, 0, width, height)
    init()

    # Configurar el callback de ratón
    glfw.set_cursor_pos_callback(window, mouse_callback)

    # Bucle principal
    while not glfw.window_should_close(window):
        draw_torus()
        glfw.poll_events()

    glfw.terminate()  # Cerrar GLFW al salir

if __name__ == "__main__":
    main()

#+END_SRC

#+RESULTS:



** Transformaciones en OpenGL
Las transformaciones de OpenGL son fundamentales para mover, rotar y escalar los objetos en la escena.

*** Traslación
   Mueve un objeto de una posición a otra.

*** Rotación
   Gira un objeto alrededor de un eje.

*** Escalado
   Cambia el tamaño del objeto.

Ejemplo de cómo aplicar una transformación de escalado y rotación:

#+begin_src python
  from OpenGL.GL import *
  from OpenGL.GLU import *
  
  glPushMatrix()         # Guardar la matriz actual
  glTranslatef(1.0, 0.0, 0.0)  # Traslación
  glRotatef(45, 0.0, 0.0, 1.0)  # Rotación de 45 grados
  glScalef(2.0, 2.0, 1.0)      # Escalar el objeto
  draw_triangle()              # Dibujar el objeto transformado
  glPopMatrix()         # Restaurar la matriz original
#+end_src

** Iluminación y Materiales
En OpenGL, puedes aplicar iluminación y definir materiales para que los objetos interactúen con la luz de manera realista.

*** Tipos de luces
   - **Luz ambiental**: Luz sin una dirección específica que ilumina
     toda la escena.
   - **Luz direccional**: Luz que proviene de una dirección específica,
     como la luz solar.
   - **Luz de punto**: Luz que emana de un punto específico, como una
     lámpara.
   - **Luz de foco**: Luz que se emite en un ángulo específico, similar
     a un reflector.

*** Materiales
   Puedes definir propiedades de los materiales, como el color y la
   reflectividad, para cada objeto.

** Sombras y Efectos Avanzados
   OpenGL también permite generar sombras y efectos avanzados como transparencia, texturas y sombreado por vértices.

** OpenGL Moderno: Shaders y el Pipeline Gráfico
OpenGL moderno (a partir de OpenGL 3.0) ha evolucionado hacia un modelo basado en shaders. Los shaders son pequeños programas que se ejecutan en la GPU y permiten controlar de manera detallada el comportamiento del pipeline gráfico.

*** Vertex Shader
   Procesa cada vértice y aplica transformaciones para determinar su posición en la pantalla.

*** Fragment Shader
   Calcula el color final de cada píxel en la superficie de los objetos.

*** Geometry Shader
   Opcional, permite manipular primitivas completas (como puntos, líneas o triángulos).

#+begin_src python
  # Ejemplo de vertex shader simple en GLSL (OpenGL Shading Language)
  """
  #version 330 core
  layout(location = 0) in vec3 position;
  uniform mat4 model;
  uniform mat4 view;
  uniform mat4 projection;
  void main() {
      gl_Position = projection * view * model * vec4(position, 1.0);
  }
  """
#+end_src

** Conclusión
OpenGL es una herramienta poderosa y flexible para el renderizado de
gráficos en 2D y 3D. Aunque es de bajo nivel y puede requerir trabajo
adicional para construir escenas complejas, su compatibilidad
multiplataforma y la aceleración por hardware lo convierten en una
opción popular en una variedad de aplicaciones.

Con el tiempo, OpenGL ha evolucionado hacia un modelo basado en
shaders, lo que permite un control mucho mayor sobre el pipeline
gráfico, haciendo posible gráficos de alta calidad y efectos avanzados
en tiempo real.
