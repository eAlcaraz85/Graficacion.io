#+TITLE: Apuntes Graficación
#+LANGUAGE: es
#+LaTeX_HEADER: \usepackage[spanish]{inputenc}
#+SETUPFILE: /home/likcos/Materias/Graficacion/theme-readtheorg-local.setup
#+EXPORT_FILE_NAME: index.html
#+OPTIONS: num:nil
#+HTML_HEAD: <style> #content{max-width:1800px;}</style>
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+OPTIONS: tex:t
#+HTML_MATHJAX: t

* Manual de Instalación de Git
** Instalación en Windows
   - Descarga el instalador desde [https://git-scm.com/].
	 
	 

- Haz clic en el botón “Download for Windows”.
   - Ejecuta el archivo descargado (.exe).
   
   - Configuración de las opciones recomendadas durante la instalación:
     - Seleccionar el editor por defecto (por ejemplo, Vim o Notepad++).
     - Usar Git desde la línea de comandos y aplicaciones de terceros (opción recomendada).
     - Opciones de formato de fin de línea: selecciona la opción predeterminada para Windows.
     
   - Completa la instalación.
   - Verifica la instalación abriendo Git Bash o Command Prompt y ejecutando:
#+BEGIN_SRC bash
git --version
#+END_SRC

** Instalación en macOS

*** Método recomendado: usando Homebrew
   - Si tienes Homebrew instalado, abre la terminal y ejecuta:
#+BEGIN_SRC bash
brew install git
#+END_SRC

*** Método alternativo: paquete descargado
   - Descarga el instalador desde [https://git-scm.com/].
   - Ejecuta el paquete descargado (.dmg).
   - Sigue las instrucciones de instalación.

   - Verifica la instalación abriendo la terminal y ejecutando:
     #+BEGIN_SRC bash
     git --version
     #+END_SRC

** Instalación en Linux (Distribuciones basadas en Debian/Ubuntu)
   - Abre la terminal y ejecuta:
     #+BEGIN_SRC bash
     sudo apt update
     sudo apt install git
     #+END_SRC
     
   - Verifica la instalación ejecutando:
     #+BEGIN_SRC bash
     git --version
     #+END_SRC

** Configuración básica de Git
   - Configura tu nombre de usuario:
     #+BEGIN_SRC bash
     git config --global user.name "Tu Nombre"
     #+END_SRC
     
   - Configura tu correo electrónico:
     #+BEGIN_SRC bash
     git config --global user.email "tuemail@ejemplo.com"
     #+END_SRC

   - Verifica la configuración:
     #+BEGIN_SRC bash
     git config --list
     #+END_SRC

** Actualización de Git
   - *Windows*: Ejecuta el instalador más reciente desde el sitio oficial.
   - *macOS*: Ejecuta:
     #+BEGIN_SRC bash
     brew upgrade git
     #+END_SRC
   - *Linux*: Ejecuta:
     #+BEGIN_SRC bash
     sudo apt update && sudo apt upgrade git
     #+END_SRC



** Configurar Llave SSH con GitHub
*** 1. Verificar si ya tienes una llave SSH
   - Abre la terminal y ejecuta el siguiente comando para verificar si ya tienes llaves SSH generadas:
     #+BEGIN_SRC bash
     ls -al ~/.ssh
     #+END_SRC
     
   - Si ves archivos como `id_rsa` o `id_ed25519`, ya tienes llaves SSH. Si no, continúa con el siguiente paso.

*** 2. Generar una nueva llave SSH
   - Si no tienes una llave SSH, genera una nueva con el siguiente comando (puedes cambiar `ed25519` por `rsa` si lo prefieres):
     #+BEGIN_SRC bash
     ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
     #+END_SRC

   - Cuando se te pregunte por la ubicación del archivo, presiona `Enter` para usar la ubicación predeterminada (`~/.ssh/id_ed25519`).
   - Puedes agregar una contraseña para proteger tu llave, pero también puedes dejarlo en blanco.

*** 3. Añadir la llave SSH al agente SSH
   - Para añadir tu nueva llave SSH al agente, asegúrate de que esté en ejecución:
     #+BEGIN_SRC bash
     eval "$(ssh-agent -s)"
     #+END_SRC

   - Añade la llave SSH al agente:
     #+BEGIN_SRC bash
     ssh-add ~/.ssh/id_ed25519
     #+END_SRC

*** 4. Copiar la llave SSH pública
   - Copia el contenido de tu llave pública para añadirla a GitHub:
     #+BEGIN_SRC bash
     cat ~/.ssh/id_ed25519.pub
     #+END_SRC
     
   - Copia el texto que aparece en la terminal (comienza con `ssh-ed25519` o `ssh-rsa`).

*** 5. Añadir la llave SSH a GitHub
   - Inicia sesión en tu cuenta de GitHub.
   - Ve a la sección de *Settings* (Configuración).
   - En el menú lateral izquierdo, selecciona **SSH and GPG keys**.
   - Haz clic en *New SSH key*.
   - Introduce un título para identificar la llave (por ejemplo, "Mi computadora personal") y pega la llave pública copiada en el campo correspondiente.
   - Haz clic en *Add SSH key*.

*** 6. Probar la conexión SSH con GitHub
   - Para verificar que todo está configurado correctamente, ejecuta el siguiente comando:
     #+BEGIN_SRC bash
     ssh -T git@github.com
     #+END_SRC

   - Si es la primera vez que te conectas, verás una advertencia preguntando si deseas continuar. Escribe `yes`.
   - Si la conexión es exitosa, verás un mensaje similar a:
     #+BEGIN_QUOTE
     Hi username! You've successfully authenticated, but GitHub does not provide shell access.
     #+END_QUOTE

*** 7. Usar la conexión SSH en repositorios de GitHub
   - Para clonar un repositorio usando SSH, utiliza la URL SSH del repositorio:
     #+BEGIN_SRC bash
     git clone git@github.com:usuario/repo.git
     #+END_SRC



** Configurar Llave SSH con GitHub en Windows

1. Git Bash: En Windows, utilizas Git Bash como terminal para ejecutar los comandos, en lugar de la terminal estándar de Linux o macOS.

2. Ruta de las llaves: En Git Bash, las rutas siguen el formato Unix (/c/Users/tu_usuario/.ssh/ en lugar de C:\Users\tu_usuario\.ssh).



*** 1. Abrir Git Bash
   - Abre **Git Bash** (es la terminal que se instala junto con Git en Windows).

*** 2. Verificar si ya tienes una llave SSH
   - En la terminal de Git Bash, ejecuta el siguiente comando para ver si ya tienes llaves SSH generadas:
     #+BEGIN_SRC bash
     ls -al ~/.ssh
     #+END_SRC

   - Si ves archivos como `id_rsa` o `id_ed25519`, ya tienes llaves SSH. Si no, continúa con el siguiente paso.

*** 3. Generar una nueva llave SSH
   - Si no tienes una llave SSH, genera una nueva con el siguiente comando:
     #+BEGIN_SRC bash
     ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
     #+END_SRC

   - Cuando se te pregunte por la ubicación del archivo, presiona `Enter` para usar la ubicación predeterminada (`/c/Users/tu_usuario/.ssh/id_ed25519`).
   - Puedes agregar una contraseña para proteger tu llave, pero también puedes dejar el campo vacío si no deseas protegerla con una contraseña.

*** 4. Añadir la llave SSH al agente SSH
   - Asegúrate de que el agente SSH esté en ejecución. En Git Bash, ejecuta:
     #+BEGIN_SRC bash
     eval "$(ssh-agent -s)"
     #+END_SRC

   - Añade tu nueva llave SSH al agente:
     #+BEGIN_SRC bash
     ssh-add ~/.ssh/id_ed25519
     #+END_SRC

*** 5. Copiar la llave SSH pública
   - Para añadir la llave SSH a GitHub, necesitas copiar tu llave pública. Ejecuta el siguiente comando en Git Bash:
     #+BEGIN_SRC bash
     cat ~/.ssh/id_ed25519.pub
     #+END_SRC

   - Copia el texto que aparece en la terminal, que comenzará con `ssh-ed25519` o `ssh-rsa`.

*** 6. Añadir la llave SSH a GitHub
   - Abre tu navegador web e inicia sesión en GitHub.
   - Ve a la sección de *Settings* (Configuración).
   - En el menú lateral izquierdo, selecciona **SSH and GPG keys**.
   - Haz clic en *New SSH key*.
   - Ponle un título descriptivo (como "Mi computadora con Windows") y pega la llave pública copiada en el campo correspondiente.
   - Haz clic en *Add SSH key*.

*** 7. Probar la conexión SSH con GitHub
   - Para asegurarte de que todo está correctamente configurado, prueba la conexión con GitHub desde Git Bash:
     #+BEGIN_SRC bash
     ssh -T git@github.com
     #+END_SRC

   - Si es la primera vez que te conectas, te pedirá confirmar la conexión escribiendo `yes`.
   - Si todo está bien, deberías ver un mensaje como:
     #+BEGIN_QUOTE
     Hi username! You've successfully authenticated, but GitHub does not provide shell access.
     #+END_QUOTE

*** 8. Usar la conexión SSH en repositorios de GitHub
   - Para clonar un repositorio usando la URL SSH, ejecuta:
     #+BEGIN_SRC bash
     git clone git@github.com:usuario/repo.git
     #+END_SRC

   

   
** Manual de Git en Windows

*** 1. Instalar Git en Windows
   - Visita [https://git-scm.com/](https://git-scm.com/) y descarga el instalador de Git para Windows.
   - Ejecuta el archivo descargado (.exe).
   - Durante la instalación, selecciona las opciones predeterminadas recomendadas.
   - Abre *Git Bash* al finalizar la instalación.

*** 2. Configurar Git
   - Abre *Git Bash* y ejecuta los siguientes comandos para configurar tu identidad:

   #+BEGIN_SRC bash
   git config --global user.name "Tu Nombre"
   git config --global user.email "tuemail@ejemplo.com"
   #+END_SRC

   - Para verificar la configuración:

   #+BEGIN_SRC bash
   git config --list
   #+END_SRC

*** 3. Clonar un repositorio
   - Para clonar un repositorio desde GitHub, usa el siguiente comando:

   #+BEGIN_SRC bash
   git clone https://github.com/usuario/repo.git
   #+END_SRC

   Esto descargará el repositorio a tu computadora.

*** 4. Comandos básicos de Git

   - *Verificar el estado del repositorio*:

   #+BEGIN_SRC bash
   git status
   #+END_SRC

   - *Añadir archivos al área de preparación (staging)*:

   #+BEGIN_SRC bash
   git add nombre_de_archivo
   #+END_SRC

   - Para añadir todos los archivos modificados:

   #+BEGIN_SRC bash
   git add .
   #+END_SRC

   - *Hacer un commit* (guardar los cambios localmente):

   #+BEGIN_SRC bash
   git commit -m "Mensaje de commit"
   #+END_SRC

   - *Enviar los cambios al repositorio remoto*:

   #+BEGIN_SRC bash
   git push
   #+END_SRC

*** 5. Actualizar el repositorio local
   - Para obtener los últimos cambios del repositorio remoto:

   #+BEGIN_SRC bash
   git pull
   #+END_SRC

*** 6. Crear y cambiar de ramas (branches)

   - *Crear una nueva rama*:

   #+BEGIN_SRC bash
   git branch nombre_de_la_rama
   #+END_SRC

   - *Cambiar a una rama existente*:

   #+BEGIN_SRC bash
   git checkout nombre_de_la_rama
   #+END_SRC

   - *Crear y cambiar a una nueva rama*:

   #+BEGIN_SRC bash
   git checkout -b nombre_de_la_rama
   #+END_SRC

*** 7. Ver historial de commits

   - Para ver el historial de cambios del repositorio:

   #+BEGIN_SRC bash
   git log
   #+END_SRC

   - Para un historial más compacto:

   #+BEGIN_SRC bash
   git log --oneline
   #+END_SRC

*** 8. Configurar una llave SSH

   - *Generar una llave SSH*:

   #+BEGIN_SRC bash
   ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
   #+END_SRC

   - *Añadir la llave al agente SSH*:

   #+BEGIN_SRC bash
   eval "$(ssh-agent -s)"
   ssh-add ~/.ssh/id_ed25519
   #+END_SRC

   - *Copiar la llave pública*:

   #+BEGIN_SRC bash
   cat ~/.ssh/id_ed25519.pub
   #+END_SRC

   - Añádela a tu cuenta de GitHub en *Settings > SSH and GPG keys*.

   
* Manual de Instalación de Python en Windows

** Paso 1: Descarga de Python
   1. Abre el navegador web y visita el sitio: [[https://www.python.org][https://www.python.org]].
   2. Ve a la pestaña "Downloads" y selecciona la versión más reciente para Windows.
   3. Haz clic en el botón que dice "Download Python (versión actual)" para descargar el instalador de Python.

** Paso 2: Ejecutar el instalador
   1. Ejecuta el archivo descargado (.exe).
   2. Asegúrate de marcar la opción ~Add Python to PATH~ antes de proceder con la instalación.
   3. Haz clic en ~Install Now~ para instalar con la configuración predeterminada.
   4. Espera a que finalice el proceso de instalación y verifica el mensaje de éxito.

** Paso 3: Verificación de la instalación
   1. Abre la línea de comandos (cmd) escribiendo "cmd" en el menú de inicio.
   2. Verifica que Python se instaló correctamente ejecutando el siguiente comando:
      #+BEGIN_SRC bash
      python --version
      #+END_SRC
   3. Abre el intérprete de Python escribiendo ~python~ en la línea de comandos:
      #+BEGIN_SRC bash
      python
      #+END_SRC
      Si todo está bien, verás el prompt interactivo de Python (tres símbolos ~>>>~).
   4. Para salir del intérprete, escribe ~exit()~ o presiona ~Ctrl + Z~ seguido de ~Enter~.

** Paso 4: Instalar pip y otros paquetes
   1. Verifica si pip está instalado escribiendo en la línea de comandos:
      #+BEGIN_SRC bash
      pip --version
      #+END_SRC
   2. Si necesitas instalar paquetes, usa pip con el siguiente comando:
      #+BEGIN_SRC bash
      pip install nombre_paquete
      #+END_SRC

** Paso 5: Configuración del entorno de desarrollo
   1. Instala un editor de código como:
      - [[https://code.visualstudio.com][Visual Studio Code]]
      - [[https://www.jetbrains.com/pycharm/][PyCharm]]
   2. Configura el editor instalando las extensiones de Python. En Visual Studio Code, busca la extensión "Python" en el panel de extensiones.

** Paso 6: Actualización de Python (opcional)
   - Para actualizar Python a una nueva versión en el futuro, descarga la última versión desde [[https://www.python.org/downloads/][python.org]] y sigue los pasos de instalación.


* Introducción a la Graficación por computadora 
   
** Graficación por Computadora

La  Graficación por Computadora (o simplemente Graficación)
se enfoca en el estudio y aplicación de técnicas, algoritmos y
herramientas para la generación y manipulación de imágenes digitales
mediante el uso de computadoras. Es una rama de la informática que
combina conceptos de matemáticas, física y programación para crear
imágenes, animaciones y efectos visuales. A continuación, te describo
los aspectos clave de esta disciplina:

*** Objetivos de la Graficación por Computadora
   1. *Generación de imágenes*: Crear imágenes digitales a partir de descripciones matemáticas y geométricas de objetos, en 2D y 3D.
   2. *Modelado de objetos*: Crear representaciones matemáticas de objetos y escenas usando técnicas como polígonos, mallas y curvas.
   3. *Renderizado*: Convertir representaciones matemáticas en imágenes visuales, simulando iluminación, sombras y texturas.
   4. *Transformaciones geométricas*: Aplicar traslaciones, rotaciones, escalados y proyecciones a objetos en sistemas de coordenadas 2D y 3D.
   5. *Iluminación y sombreado*: Simular cómo la luz interactúa con los objetos para crear efectos realistas.
   6. *Animación*: Generar secuencias de imágenes que cambian a lo largo del tiempo, incluyendo movimientos y simulaciones físicas.
   7. *Texturizado*: Aplicar imágenes (texturas) sobre superficies para dar detalles visuales sin aumentar la complejidad geométrica.
   8. *Interacción gráfica*: Estudiar técnicas para interactuar con imágenes o modelos gráficos, como interfaces gráficas, realidad aumentada o virtual.

*** Áreas de estudio en Graficación por Computadora
   1. *Matemáticas*: Uso de geometría y álgebra lineal para realizar transformaciones geométricas y modelar objetos.
   2. *Programación*: Conocimiento de lenguajes como C++, Python, GLSL y HLSL para implementar algoritmos gráficos.
   3. *Algoritmos gráficos*: Estudio de algoritmos como el trazado de rayos (ray tracing), rasterización y z-buffering.
   4. *Herramientas gráficas*: Uso de APIs como OpenGL, DirectX o Vulkan para crear gráficos y animaciones.
   5. *Física aplicada*: Simulación de fenómenos físicos como gravedad y movimiento para generar gráficos realistas.

*** Aplicaciones de la Graficación por Computadora
   - *Videojuegos*: Creación de ambientes, personajes y efectos visuales.
   - *Cine y efectos visuales*: Creación de efectos especiales y animación por computadora.
   - *Diseño industrial y arquitectónico*: Modelado y visualización de prototipos y estructuras.
   - *Simulaciones*: Uso en medicina, aeronáutica y otras industrias para crear simulaciones realistas.
   - *Realidad virtual y aumentada*: Generación de entornos interactivos virtuales.

*** Temas principales en Graficación por Computadora
   - *Modelado 2D y 3D*
   - *Algoritmos de rasterización*
   - *Transformaciones y proyecciones*
   - *Renderizado y sombreado*
   - *Texturizado*
   - *Iluminación global y local*
   - *Técnicas de animación*
   - *Programación de shaders*
   - *Interacción gráfica y diseño de interfaces*
   

** Modelos de Color: RGB, CMY, HSV y HSL

** Introducción
Los *modelos de color* son representaciones matemáticas que describen
cómo los colores pueden representarse en diversas formas utilizando
valores numéricos. Estos modelos son esenciales en gráficos por
computadora, procesamiento de imágenes y en la percepción del color. A
continuación, se detallan los modelos más comunes: RGB, CMY, HSV y
HSL.

** Modelo de Color RGB (Red, Green, Blue)

** Definición
El modelo de color *RGB* (Rojo, Verde, Azul) es un modelo de mezcla aditiva, que se utiliza principalmente en dispositivos que emiten luz, como pantallas, cámaras digitales y proyectores. Los tres colores primarios (Rojo, Verde y Azul) se combinan de diferentes maneras para crear una amplia gama de colores.

** Funcionamiento de la Mezcla Aditiva
En el modelo RGB, los colores se generan mediante la combinación de luz. Cuanto más intensa es la luz en cada canal (rojo, verde o azul), más claro es el color resultante. Cuando todas las intensidades están al máximo, el color resultante es blanco; cuando todas las intensidades están al mínimo, el resultado es negro.

- *Fórmula para la mezcla aditiva*:
  \[
  \text{Color} = R \cdot \mathbf{r} + G \cdot \mathbf{g} + B \cdot \mathbf{b}
  \]
  donde:
  - \(R\), \(G\) y \(B\) son las intensidades de los canales rojo, verde y azul, respectivamente.
  - \( \mathbf{r} \), \( \mathbf{g} \) y \( \mathbf{b} \) son los vectores unitarios que representan los colores primarios.

- *Ejemplo*:
  - Si \( R = 255 \), \( G = 0 \), \( B = 0 \), obtenemos un color rojo puro.
  - Si \( R = 0 \), \( G = 255 \), \( B = 0 \), obtenemos un color verde puro.
  - Si \( R = 255 \), \( G = 255 \), \( B = 0 \), obtenemos el color amarillo.

** Espacio de Color RGB
El espacio de color *RGB* puede representarse como un cubo tridimensional, donde:
  - El eje X corresponde al canal rojo (\(R\)),
  - El eje Y al canal verde (\(G\)),
  - Y el eje Z al canal azul (\(B\)).
  
Cada vértice del cubo representa un color primario o la combinación de ellos, como se muestra a continuación:
  - \( (0, 0, 0) \): Negro (ausencia de luz).
  - \( (255, 0, 0) \): Rojo.
  - \( (0, 255, 0) \): Verde.
  - \( (0, 0, 255) \): Azul.
  - \( (255, 255, 255) \): Blanco (máxima intensidad en todos los canales).
  - \( (255, 255, 0) \): Amarillo (combinación de rojo y verde).

Este espacio de color es útil para representar los colores generados en dispositivos electrónicos, ya que estos emiten luz en diferentes combinaciones de rojo, verde y azul.

** Conversión a otros modelos de color
El modelo RGB puede convertirse a otros espacios de color como *CMY*, *HSV* o *HSL*. A continuación se muestra la conversión básica de RGB a CMY:

- *Conversión de RGB a CMY*:
  \[
  C = 1 - \left( \frac{R}{255} \right), \quad M = 1 - \left( \frac{G}{255} \right), \quad Y = 1 - \left( \frac{B}{255} \right)
  \]
  donde \(R\), \(G\), y \(B\) son las intensidades de los canales en el rango de [0, 255].

** Aplicaciones del Modelo RGB
El modelo de color RGB se usa ampliamente en:
- *Monitores y pantallas*: Dispositivos como televisores, monitores de computadora y pantallas de teléfonos móviles utilizan píxeles que emiten luz en diferentes intensidades de rojo, verde y azul para representar imágenes.
- *Cámaras digitales*: Los sensores de las cámaras capturan la luz en estos tres canales para generar imágenes en color.
- *Gráficos por computadora*: El modelo RGB es esencial en software de edición de imágenes, renderizado 3D y creación de gráficos visuales.

** Limitaciones del Modelo RGB
Aunque el modelo RGB es excelente para dispositivos que emiten luz, tiene algunas limitaciones:
- No es intuitivo para el ser humano al ajustar el brillo o la saturación de un color, ya que requiere manipular los tres canales de manera independiente.
- El modelo RGB no es el más adecuado para tareas de impresión, ya que en impresiones se usan modelos basados en la mezcla sustractiva de colores, como CMY o CMYK.





** Modelo CMY (Cyan, Magenta, Yellow)
El modelo *CMY* es un modelo de mezcla sustractiva que utiliza los colores cian, magenta y amarillo. Es el modelo base para la impresión en color.

- *Características*:
  - Cada color se describe en términos de cuánto absorbe (resta) de la luz blanca que incide.

- *Mezcla sustractiva*:
  - La relación entre CMY y RGB es:
	\[
	\text{C} = 1 - \left( \frac{R}{L} \right), \quad \text{M} = 1 - \left( \frac{G}{L} \right), \quad \text{Y} = 1 - \left( \frac{B}{L} \right)
	\]

   donde \( L \) es el valor máximo de intensidad (por ejemplo, 255).

- *Conversión de RGB a CMY*:
  - Si los valores RGB están normalizados entre 0 y 1:

	\[
    \text{C} = 1 - R, \quad \text{M} = 1 - G, \quad \text{Y} = 1 - B
    \]

- *Aplicaciones*:
  - Utilizado en la impresión de imágenes en color, como impresoras de inyección de tinta y offset.

** Modelo HSV (Hue, Saturation, Value)
El modelo *HSV* es una representación más intuitiva del color basada en la percepción humana, donde el matiz, la saturación y el valor describen un color.

- *Características*:
  - *Matiz (Hue, H)*: Representa el ángulo en el círculo cromático, en grados [0°, 360°).
  - *Saturación (S)*: Indica la pureza del color, rango de [0,1].
  - *Valor (V)*: Define el brillo del color, rango de [0,1].

- *Conversión de RGB a HSV*:
  - Primero, normalizar los valores RGB entre 0 y 1:
	\[
    R' = \frac{R}{L}, \quad G' = \frac{G}{L}, \quad B' = \frac{B}{L}
    \]

	donde \( L \) es el valor máximo de intensidad (por ejemplo, 255).

  - Calcular el valor máximo y mínimo:
    \[
    C_{\max} = \max(R', G', B'), \quad C_{\min} = \min(R', G', B')
    \]

  - Diferencia:
    \[
    \Delta = C_{\max} - C_{\min}
    \]

  - *Cálculo del Matiz (H)*:
    \[
    \text{Si } \Delta = 0 \Rightarrow H = 0 \\
    \text{Si } C_{\max} = R' \Rightarrow H = 60^\circ \times \left( \frac{G' - B'}{\Delta} \mod 6 \right) \\
    \text{Si } C_{\max} = G' \Rightarrow H = 60^\circ \times \left( \frac{B' - R'}{\Delta} + 2 \right) \\
    \text{Si } C_{\max} = B' \Rightarrow H = 60^\circ \times \left( \frac{R' - G'}{\Delta} + 4 \right)
    \]

  - *Cálculo de la Saturación (S)*:
    \[
    \text{Si } C_{\max} = 0 \Rightarrow S = 0 \\
    \text{Si no} \Rightarrow S = \frac{\Delta}{C_{\max}}
    \]

  - *Cálculo del Valor (V)*:
    \[
	V = C_{\max}
    \]

- *Aplicaciones*:
  - Edición de imágenes, interfaces de selección de color y en procesamiento de video.

- *Ejemplo*:
  - Convertir RGB (255, 255, 0) a HSV:
    - Normalizar:
      \[
      R' = 1, \quad G' = 1, \quad B' = 0
      \]
    - \( C_{\max} = 1 \), \( C_{\min} = 0 \), \( \Delta = 1 \)
    - Calcular H:
      \[
      H = 60^\circ \times \left( \frac{G' - B'}{\Delta} \mod 6 \right) = 60^\circ \times (1 \mod 6) = 60^\circ
      \]
    - Calcular S:
      \[
      S = \frac{\Delta}{C_{\max}} = \frac{1}{1} = 1
      \]
    - Calcular V:
      \[
      V = C_{\max} = 1
      \]
    - *Resultado*: H = 60°, S = 1, V = 1 (Color amarillo)

** Modelo HSL (Hue, Saturation, Lightness)
El modelo *HSL* es similar al modelo HSV, pero en lugar de "valor" utiliza el término *luminosidad (Lightness)*, que representa la cantidad de luz que refleja un color.

- *Características*:
  - *Matiz (Hue, H)*: Mismo que en HSV.
  - *Saturación (S)*: Diferente definición que en HSV.
  - *Luminosidad (L)*: Rango de [0,1], donde 0 es negro, 0.5 es el color puro, y 1 es blanco.

- *Conversión de RGB a HSL*:
  - Normalizar RGB:
    \[
    R' = \frac{R}{L}, \quad G' = \frac{G}{L}, \quad B' = \frac{B}{L}
    \]

  - Calcular \( C_{\max} \) y \( C_{\min} \), y \( \Delta \) como en HSV.

  - **Cálculo de la Luminosidad (L)**:
    \[
    L = \frac{C_{\max} + C_{\min}}{2}
    \]

  - *Cálculo de la Saturación (S)*:
    \[
    \text{Si } \Delta = 0 \Rightarrow S = 0 \\
    \text{Si } L \leq 0.5 \Rightarrow S = \frac{\Delta}{C_{\max} + C_{\min}} \\
    \text{Si } L > 0.5 \Rightarrow S = \frac{\Delta}{2 - (C_{\max} + C_{\min})}
    \]

  - *Cálculo del Matiz (H)*:
    - Igual que en HSV.

- *Aplicaciones*:
  - Herramientas de diseño gráfico y edición de imágenes, donde se necesita un control preciso sobre la luz y el color.

- *Ejemplo*:
  - Convertir RGB (255, 0, 0) a HSL:
    - Normalizar:
      \[
      R' = 1, \quad G' = 0, \quad B' = 0
      \]
    - \( C_{\max} = 1 \), \( C_{\min} = 0 \), \( \Delta = 1 \)
    - Calcular L:
      \[
      L = \frac{1 + 0}{2} = 0.5
      \]
    - Calcular S:
      \[
      S = \frac{\Delta}{C_{\max} + C_{\min}} = \frac{1}{1 + 0} = 1
      \]
    - Calcular H:
      \[
      H = 60^\circ \times \left( \frac{G' - B'}{\Delta} \mod 6 \right) = 0^\circ
      \]
    - **Resultado**: H = 0°, S = 1, L = 0.5 (Color rojo puro)




** Operadores Puntuales

*** Definición
Los *operadores puntuales* son una clase de transformaciones aplicadas
en el procesamiento digital de imágenes que operan sobre cada píxel de
manera independiente. Esto significa que el valor de salida de un
píxel depende únicamente del valor de ese mismo píxel en la imagen de
entrada, sin considerar los valores de los píxeles vecinos.

*** Características
1. *Independencia espacial*: Los operadores puntuales solo modifican
   cada píxel basado en su valor original, sin tener en cuenta su
   entorno.
2. *Simplicidad computacional*: Dado que no se necesita información de
   los píxeles vecinos, estas operaciones suelen ser más rápidas y
   eficientes.
3. *Aplicación en tiempo real*: Su bajo costo computacional los hace
   adecuados para aplicaciones de procesamiento de imágenes en tiempo
   real.

*** Tipos de Operadores Puntuales

**** Operador de Identidad
   - No altera la imagen. Cada píxel de la imagen de salida tiene el
     mismo valor que el píxel correspondiente en la imagen de entrada.
   - Fórmula: \( g(x, y) = f(x, y) \), donde \( f(x, y) \) es el valor del píxel original y \( g(x, y) \) es el valor del píxel modificado.

**** Negativo de la Imagen
   - Este operador invierte los valores de los píxeles de una imagen, produciendo su negativo.
   - Fórmula: \( g(x, y) = L - 1 - f(x, y) \), donde \( L \) es el valor máximo posible en la imagen (por ejemplo, 255 en imágenes de 8 bits).
   - Uso: Se utiliza en técnicas como la extracción de detalles o cuando es necesario invertir una imagen para un análisis.

**** Umbralización (Thresholding)
   - Convierte la imagen a una versión binaria, donde los píxeles con valores por encima de un umbral se establecen en un valor (generalmente blanco), y los que están por debajo se establecen en otro (generalmente negro).
   - Fórmula: 
     \[
     g(x, y) =
     0, & \text{si } f(x, y) \leq T \\
     L, & \text{si } f(x, y) > T
     \]
   - Uso: Se utiliza para segmentación de imágenes y procesamiento de imágenes en blanco y negro.

**** Corrección Gamma
   - Ajusta los valores de intensidad de los píxeles para modificar el brillo o contraste de la imagen.
   - Fórmula: \( g(x, y) = c \cdot f(x, y)^\gamma \), donde \( c \) es una constante de escala, y \( \gamma \) es el factor de corrección.
   - Uso: Corrige la distorsión de brillo en pantallas o para obtener una mejor representación visual.

**** Transformaciones Logarítmicas
   - Aumentan los detalles en regiones oscuras de la imagen al expandir los valores de intensidad bajos.
   - Fórmula: \( g(x, y) = c \cdot \log(1 + f(x, y)) \), donde \( c \) es una constante.
   - Uso: Mejora la visualización de imágenes con una alta gama dinámica (HDR), como imágenes astronómicas.

**** Corrección Lineal o Estiramiento de Contraste
   - Expande los valores de intensidad en una imagen para cubrir un rango más amplio, aumentando el contraste.
   - Fórmula:
     \[
     g(x, y) = \frac{f(x, y) - f_{\min}}{f_{\max} - f_{\min}} \cdot (L - 1)
     \]
   - Uso: Aumenta el contraste en imágenes con poca variación de intensidad.

**** Transformaciones de Potencia (Raise to Power Transform)
   - Eleva cada valor de píxel a una potencia \( n \), lo que permite ajustar el brillo y contraste de una imagen.
   - Fórmula: \( g(x, y) = c \cdot f(x, y)^n \).

*** Aplicaciones de Operadores Puntuales
- *Corrección de imágenes*: Mejoran el brillo, contraste, y otros aspectos visuales de una imagen.
- *Segmentación*: La umbralización es comúnmente usada para separar objetos de fondo en una imagen.
- *Análisis médico*: Se utiliza para mejorar la visualización de imágenes de rayos X, resonancias magnéticas o ultrasonidos.
- *Procesamiento en tiempo real*: Los operadores puntuales son útiles en sistemas que requieren una rápida respuesta, como cámaras de vigilancia o sistemas de visión artificial.

En resumen, los *operadores puntuales* son una herramienta fundamental en el procesamiento de imágenes que permiten realizar transformaciones sencillas pero efectivas, mejorando la calidad visual o preparándolas para análisis posteriores.



** Proceso de Multiplicación de una Matriz de Transformación por una Coordenada de Píxel

Cuando aplicamos una transformación geométrica a una imagen, multiplicamos las coordenadas de cada píxel por una *matriz de transformación*. Este proceso se desglosa paso a paso de la siguiente manera.

*** 1. Representación de las coordenadas en forma homogénea
Las coordenadas \((x, y)\) de un píxel se convierten a *coordenadas homogéneas* para que las traslaciones puedan representarse mediante multiplicaciones de matrices. Un píxel en coordenadas homogéneas es:

\begin{pmatrix}
x \\
y \\
1
\end{pmatrix}

*** 2. Definición de la matriz de transformación
La matriz de transformación afín general tiene la forma:
\[
T= \begin{pmatrix}
a_{11} & a_{12} & t_x \\
a_{21} & a_{22} & t_y \\
0 & 0 & 1
\end{pmatrix}
\]

- \(a_{11}, a_{12}, a_{21}, a_{22}\) definen las transformaciones de rotación, escalado y cizallamiento.
- \(t_x, t_y\) son los parámetros de traslación en los ejes \(x\) e \(y\).

*** 3. Multiplicación de la matriz por las coordenadas
Multiplicamos la matriz de transformación \(T\) por las coordenadas homogéneas \((x, y, 1)\) para obtener las nuevas coordenadas \((x', y', 1)\).

$$
\begin{pmatrix}
x' \\
y' \\
1
\end{pmatrix}
=
\begin{pmatrix}
a_{11} & a_{12} & t_x \\
a_{21} & a_{22} & t_y \\
0 & 0 & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
x \\
y \\
1
\end{pmatrix}
$$


La multiplicación de matrices se desglosa a continuación.

**** 3.1 Cálculo del nuevo valor de \(x'\)

\[
x' = a_{11} \cdot x + a_{12} \cdot y + t_x
\]

**** 3.2 Cálculo del nuevo valor de \(y'\)
\[
y' = a_{21} \cdot x + a_{22} \cdot y + t_y
\]

**** 3.3 El valor constante de la tercera coordenada
La tercera coordenada se mantiene como \(1\), ya que no cambia en las transformaciones afines.

\[1 = (0 \cdot x) + (0 \cdot y) + 1 \]

*** 4. Resultado final
El resultado de la multiplicación es un nuevo vector con las coordenadas transformadas:

\begin{pmatrix}
x' \\
y' \\
1
\end{pmatrix}

*** Ejemplo concreto: Rotación
Si queremos rotar un píxel \((x, y)\) en un ángulo \(\theta\), usamos la matriz de rotación:

\[
R = \begin{pmatrix}
\cos(\theta) & -\sin(\theta) & 0 \\
\sin(\theta) & \cos(\theta) & 0 \\
0 & 0 & 1
\end{pmatrix}
\]

Multiplicamos esta matriz por las coordenadas homogéneas:

\[
\begin{pmatrix}
x' \\
y' \\
1
\end{pmatrix}
=
\begin{pmatrix}
\cos(\theta) & -\sin(\theta) & 0 \\
\sin(\theta) & \cos(\theta) & 0 \\
0 & 0 & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
x \\
y \\
1
\end{pmatrix}
\]
Esto resulta en las nuevas coordenadas después de la rotación:

\[
x' = x \cdot \cos(\theta) - y \cdot \sin(\theta)
y' = x \cdot \sin(\theta) + y \cdot \cos(\theta)
\]
*** Resumen del proceso
1. Convertir las coordenadas \((x, y)\) a coordenadas homogéneas \((x, y, 1)\).
2. Definir la matriz de transformación \(T\).
3. Multiplicar la matriz \(T\) por las coordenadas homogéneas.
4. Obtener las nuevas coordenadas \((x', y')\) que represe

** Transformaciones Geométricas en Imágenes

Las *transformaciones geométricas* en imágenes permiten cambiar la posición, orientación y escala de las imágenes sin alterar su contenido. Estas transformaciones son esenciales en tareas como alineación de imágenes, registro de imágenes, realidad aumentada, y sistemas de visión por computadora.

*** 1. Traslación (Translation)

   La traslación desplaza la imagen en el espacio sin modificar su forma o tamaño. La fórmula matemática es:

   \[
   T(x, y) = (x + t_x, y + t_y)
   \]

   Donde \(t_x\) y \(t_y\) son las cantidades de desplazamiento. La matriz de traslación es:

   \[
   T = \begin{pmatrix}
   1 & 0 & t_x \\
   0 & 1 & t_y \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 2. Rotación (Rotation)

   La rotación gira la imagen un ángulo \(\theta\). La ecuación de rotación es:

   \[
   R(x, y) = (x' , y') = \left( x \cdot \cos(\theta) - y \cdot \sin(\theta), x \cdot \sin(\theta) + y \cdot \cos(\theta) \right)
   \]

   La matriz de rotación es:

   \[
   R = \begin{pmatrix}
   \cos(\theta) & -\sin(\theta) & 0 \\
   \sin(\theta) & \cos(\theta) & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 3. Escalado (Scaling)

   El escalado modifica el tamaño de la imagen mediante factores \(s_x\) y \(s_y\). La fórmula es:

   \[
   S(x, y) = (s_x \cdot x, s_y \cdot y)
   \]

   La matriz correspondiente es:

   \[
   S = \begin{pmatrix}
   s_x & 0 & 0 \\
   0 & s_y & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 4. Cizallamiento (Shearing)

   El cizallamiento inclina la imagen en una dirección específica. Las ecuaciones para un cizallamiento horizontal y vertical son:

   \[
   Sh_x(x, y) = (x + h_x \cdot y, y)
   \]
   \[
   Sh_y(x, y) = (x, y + h_y \cdot x)
   \]

   Las matrices correspondientes son:

   Horizontal:

   \[
   Sh_x = \begin{pmatrix}
   1 & h_x & 0 \\
   0 & 1 & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

   Vertical:

   \[
   Sh_y = \begin{pmatrix}
   1 & 0 & 0 \\
   h_y & 1 & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 5. Reflexión (Reflection)

   La reflexión voltea la imagen sobre un eje. Las matrices para reflexiones sobre el eje \(x\) o \(y\) son:

   \[
   R_x = \begin{pmatrix}
   1 & 0 & 0 \\
   0 & -1 & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

   \[
   R_y = \begin{pmatrix}
   -1 & 0 & 0 \\
   0 & 1 & 0 \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 6. Transformación Afín (Affine Transformation)

   Una transformación afín combina varias de las anteriores. Su matriz es:

   \[
   A = \begin{pmatrix}
   a_{11} & a_{12} & t_x \\
   a_{21} & a_{22} & t_y \\
   0 & 0 & 1
   \end{pmatrix}
   \]

*** 7. Transformación Proyectiva (Homografía)

   La homografía proyecta una imagen en un nuevo plano, alterando su perspectiva. La matriz homográfica es:

   \[
   H = \begin{pmatrix}
   h_{11} & h_{12} & h_{13} \\
   h_{21} & h_{22} & h_{23} \\
   h_{31} & h_{32} & h_{33}
   \end{pmatrix}
   \]

*** Aplicaciones

   Las transformaciones geométricas se utilizan en:

   - *Alineación de imágenes*: Registrar imágenes para tener la misma perspectiva.
   - *Corrección de distorsión*: Corregir distorsiones causadas por lentes de cámaras.
   - *Visión artificial*: Identificar objetos en diferentes orientaciones.
   - *Realidad aumentada*: Ajustar objetos virtuales al mundo real.


* Programación

** Programas Unidad 1 
*** Creación de una Imagen


#+BEGIN_SRC python
import numpy as np   # Importa la librería NumPy, útil para trabajar con arreglos y operaciones numéricas.
import cv2 as cv     # Importa la librería OpenCV, que se utiliza para procesamiento de imágenes.

# Crea una imagen de 500x500 píxeles, todos con valor 240 (gris claro). 
# La imagen tiene solo un canal (escala de grises) y está inicializada con valores de tipo uint8 (enteros sin signo de 8 bits).
img = np.ones((500, 500), dtype=np.uint8) * 240

# Modifica algunos píxeles específicos en las coordenadas (30, 30) a (30, 35) para que tengan un valor de 1 (casi negro).
# Esto creará una pequeña línea vertical de 6 píxeles en la imagen de color casi negro.
img[30, 30] = 1
img[30, 31] = 1
img[30, 32] = 1
img[30, 33] = 1
img[30, 34] = 1
img[30, 35] = 1

# Muestra la imagen en una ventana con el título 'img'. 
cv.imshow('img', img)

# Espera a que el usuario presione cualquier tecla para continuar.
cv.waitKey()

# Cierra todas las ventanas creadas por OpenCV.
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None

*** Cargar Imagen 
#+BEGIN_SRC python :result output
import cv2 as cv  # Importa la librería OpenCV, que se usa para el procesamiento de imágenes y videos.

# Lee una imagen desde el archivo 'tr.png'. 
# El segundo argumento '1' indica que se leerá la imagen en color (1 para color, 0 para escala de grises, -1 para incluir el canal alfa si existe).
img = cv.imread('tr.png', 1)

# Muestra la imagen leída en una ventana llamada 'ejemplo'.
cv.imshow('ejemplo', img)

# Espera indefinidamente hasta que el usuario presione una tecla.
cv.waitKey(0)

# Cierra todas las ventanas abiertas por OpenCV.
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None

*** Split y Merge Imagen 
#+BEGIN_SRC python :result output
import cv2 as cv  # Importa OpenCV, que es útil para procesamiento de imágenes.
import numpy as np  # Importa NumPy, que es útil para trabajar con matrices y operaciones numéricas.

# Carga la imagen '1a.png' en color (1 para color, 0 para escala de grises).
img = cv.imread('1a.png', 1)

# Crea una imagen vacía (llena de ceros, que representa color negro) con el mismo tamaño que la imagen original.
# La imagen vacía tiene un solo canal (escala de grises), por lo que se usa `img.shape[:2]` para obtener las dimensiones de la imagen (alto, ancho).
img2 = np.zeros((img.shape[:2]), dtype=np.uint8)

# Imprime las dimensiones de la imagen en la terminal (alto, ancho).
print(img.shape[:2])

# Separa los canales rojo (r), verde (g) y azul (b) de la imagen utilizando la función `cv.split()`.
r, g, b = cv.split(img)

# Recombina los canales, pero los reorganiza como rojo, azul y verde (RBG en lugar de RGB).
img3 = cv.merge([r, b, g])

# Crea una imagen que contiene solo el canal rojo, llenando los otros dos canales (verde y azul) con ceros (negro).
r = cv.merge([r, img2, img2])

# Crea una imagen que contiene solo el canal verde, llenando los otros dos canales (rojo y azul) con ceros.
g = cv.merge([img2, g, img2])

# Crea una imagen que contiene solo el canal azul, llenando los otros dos canales (rojo y verde) con ceros.
b = cv.merge([img2, img2, b])

# Muestra la imagen original en una ventana llamada 'ejemplo'.
cv.imshow('ejemplo', img)

# Muestra la imagen que contiene solo el canal rojo.
cv.imshow('r', r)

# Muestra la imagen que contiene solo el canal verde.
cv.imshow('g', g)

# Muestra la imagen que contiene solo el canal azul.
cv.imshow('b', b)

# Muestra la imagen con los canales reorganizados (RBG en lugar de RGB).
cv.imshow('img3', img3)

# Espera indefinidamente a que el usuario presione una tecla.
cv.waitKey(0)

# Cierra todas las ventanas abiertas por OpenCV.
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None

*** Ejemplo de Operador Puntual en Imágenes 
#+BEGIN_SRC python :results output
import cv2 as cv

img = cv.imread('tr.png', 0)
cv.imshow('salida', img)
x,y=img.shape
for i in range(x):
	for j in range(y):
		if(img[i,j]>150):
			img[i,j]=255
		else:
			img[i,j]=0


cv.imshow('negativo', img)
print( img.shape, x , y)
cv.waitKey(0)
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: (632, 635) 632 635

*** Cargar vídeo Opencv 
#+BEGIN_SRC python
import cv2 as cv
import numpy as np
cap = cv.VideoCapture(0)

while(True):
    ret, img = cap.read()
    if ret:
        cv.imshow('video', img)
        img2 = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
        hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
        w,h = img2.shape
        img3=255-img2
        cv.imshow('img2', img2)
        cv.imshow('hsv', hsv)
        cv.imshow('img3', img3)
        
        k =cv.waitKey(1) & 0xFF
        if k == 27 :
	    break
    else:
        break
    
cap.release()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None

 

** Ejemplos de Transformaciones Geométricas en Modo Raw en Python

*** 1. Traslación
En esta transformación, desplazamos la imagen en el espacio sumando un valor fijo a las coordenadas de los píxeles.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Crear una imagen vacía para la traslación
translated_img = np.zeros((x, y), dtype=np.uint8)

# Definir el desplazamiento en x e y
dx, dy = 100, 50

# Trasladar la imagen
for i in range(x):
    for j in range(y):
        new_x = i + dy
        new_y = j + dx
        if 0 <= new_x < x and 0 <= new_y < y:
            translated_img[new_x, new_y] = img[i, j]

# Mostrar la imagen original y la trasladada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Trasladada', translated_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 2. Rotación (alrededor del centro de la imagen)
La rotación se realiza alrededor del centro de la imagen, utilizando las fórmulas matemáticas correspondientes.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np
import math

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Crear una imagen vacía para almacenar el resultado
rotated_img = np.zeros((x*2, y*2), dtype=np.uint8)
xx, yy = rotated_img.shape
# Calcular el centro de la imagen
cx, cy = int(x  // 2), int(y  // 2)

# Definir el ángulo de rotación (en grados) y convertirlo a radianes
angle = 45
theta = math.radians(angle)

# Rotar la imagen
for i in range(x):
    for j in range(y):
        new_x = int((j - cx) * math.cos(theta) - (i - cy) * math.sin(theta) + cx)
        new_y = int((j - cx) * math.sin(theta) + (i - cy) * math.cos(theta) + cy)
        if 0 <= new_x < y and 0 <= new_y < x:
            rotated_img[new_y, new_x] = img[i, j]

# Mostrar la imagen original y la rotada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Rotada (modo raw)', rotated_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None

*** 3. Escalado
El escalado cambia el tamaño de la imagen multiplicando las coordenadas por un factor de escala.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Definir el factor de escala
scale_x, scale_y = 0.5, 0.5

# Crear una nueva imagen para almacenar el escalado
scaled_img = np.zeros((int(x * scale_y), int(y * scale_x)), dtype=np.uint8)

# Aplicar el escalado
for i in range(int(x * scale_y)):
    for j in range(int(y * scale_x)):
        orig_x = int(i * scale_y)
        orig_y = int(j * scale_x)
        if 0 <= orig_x < x and 0 <= orig_y < y:
            scaled_img[i, j] = img[orig_x, orig_y]

# Mostrar la imagen original y la escalada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Escalada (modo raw)', scaled_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 4. Cizallamiento (Shearing)
En el cizallamiento, los píxeles se desplazan en una dirección proporcional a otra, lo que inclina la imagen.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Crear una imagen vacía para el cizallamiento
sheared_img = np.zeros((x, y), dtype=np.uint8)

# Definir el factor de cizallamiento
shear_factor_x = 0.5

# Aplicar el cizallamiento en el eje x
for i in range(x):
    for j in range(y):
        new_x = i
        new_y = int(j + shear_factor_x * i)
        if 0 <= new_x < x and 0 <= new_y < y:
            sheared_img[new_x, new_y] = img[i, j]

# Mostrar la imagen original y la cizallada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Cizallada (modo raw)', sheared_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 5. Reflexión (Reflection)
La reflexión voltea la imagen sobre un eje, como el eje vertical o horizontal.

**** Reflexión horizontal
#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Crear una imagen vacía para la reflexión
reflected_img = np.zeros((x, y), dtype=np.uint8)

# Aplicar la reflexión horizontal
for i in range(x):
    for j in range(y):
        reflected_img[i, y - j - 1] = img[i, j]

# Mostrar la imagen original y la reflejada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Reflejada Horizontalmente (modo raw)', reflected_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

**** Reflexión vertical
#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Crear una imagen vacía para la reflexión
reflected_img = np.zeros((x, y), dtype=np.uint8)

# Aplicar la reflexión vertical
for i in range(x):
    for j in range(y):
        reflected_img[x - i - 1, j] = img[i, j]

# Mostrar la imagen original y la reflejada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Reflejada Verticalmente (modo raw)', reflected_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC


** Ejemplos de Transformaciones Geométricas en Python usando OpenCV

*** 1. Traslación
En OpenCV, la traslación se realiza usando matrices de transformación afín y la función `cv.warpAffine()`.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Definir el desplazamiento en x e y
dx, dy = 100, 50

# Crear la matriz de traslación
M = np.float32([[1, 0, dx], [0, 1, dy]])

# Aplicar la traslación usando warpAffine
translated_img = cv.warpAffine(img, M, (y, x))

# Mostrar la imagen original y la trasladada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Trasladada', translated_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 2. Rotación (alrededor del centro de la imagen)
La rotación alrededor del centro de la imagen se puede realizar con la función `cv.getRotationMatrix2D()`.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Calcular el centro de la imagen
center = (y // 2, x // 2)

# Definir el ángulo de rotación (en grados)
angle = 45

# Crear la matriz de rotación
M = cv.getRotationMatrix2D(center, angle, 1.0)

# Aplicar la rotación usando warpAffine
rotated_img = cv.warpAffine(img, M, (y, x))

# Mostrar la imagen original y la rotada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Rotada', rotated_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 3. Escalado
El escalado se puede realizar usando la función `cv.resize()`.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Definir el factor de escala
scale_x, scale_y = 0.5, 0.5

# Aplicar el escalado usando cv.resize()
scaled_img = cv.resize(img, None, fx=scale_x, fy=scale_y)

# Mostrar la imagen original y la escalada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Escalada', scaled_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 4. Cizallamiento (Shearing)
El cizallamiento se puede realizar creando una matriz de transformación afín personalizada.

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Obtener el tamaño de la imagen
x, y = img.shape

# Definir el factor de cizallamiento
shear_factor = 0.5

# Crear la matriz de cizallamiento
M = np.float32([[1, shear_factor, 0], [0, 1, 0]])

# Aplicar el cizallamiento usando warpAffine
sheared_img = cv.warpAffine(img, M, (y, x))

# Mostrar la imagen original y la cizallada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Cizallada', sheared_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

*** 5. Reflexión (Reflection)
En OpenCV, la reflexión de una imagen se realiza con la función `cv.flip()`.

**** Reflexión horizontal
#+BEGIN_SRC python
import cv2 as cv

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Aplicar la reflexión horizontal usando cv.flip()
reflected_img = cv.flip(img, 1)

# Mostrar la imagen original y la reflejada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Reflejada Horizontalmente', reflected_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

**** Reflexión vertical
#+BEGIN_SRC python
import cv2 as cv

# Cargar la imagen en escala de grises
img = cv.imread('tr.png', 0)

# Aplicar la reflexión vertical usando cv.flip()
reflected_img = cv.flip(img, 0)

# Mostrar la imagen original y la reflejada
cv.imshow('Imagen Original', img)
cv.imshow('Imagen Reflejada Verticalmente', reflected_img)
cv.waitKey(0)
cv.destroyAllWindows()
#+END_SRC

** Primitivas de Dibujo

#+BEGIN_SRC python

import cv2 as cv
import numpy as np

img = np.ones((500, 500, 3), dtype=np.uint8)*255 
cv.circle(img, (250, 250), 50, (0,234,21), -1)
cv.circle(img, (250, 250), 30, (0,0,0), -1)

cv.line(img, (1,1), (230, 240), (0,234,21), 3   )
cv.rectangle(img, (20,20), (50,60), (0,0,0), 3 )
pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)
pts = pts.reshape((-1,1,2))
cv.polylines(img,[pts],True,(0,0,0), 3)
cv.imshow('img', img)
cv.waitKey()
cv.destroyAllWindows()



#+END_SRC

#+BEGIN_SRC python
import cv2 as cv
import numpy as np

img = np.ones((500, 500), dtype=np.uint8)*255 

for i in range(50):
    cv.circle(img, (250+i, 250+i), 20+i, (0,234,21), -1)
    cv.imshow('img', img)
    #img = np.ones((500, 500, 3), dtype=np.uint8)*255 
    cv.waitKey(40)

cv.waitKey(0)
cv.destroyAllWindows()


#+END_SRC

#+RESULTS:
: None

** Parametricas

#+BEGIN_SRC python
import numpy as np
import cv2

# Función para generar un solo punto de la elipse en función del parámetro t
def generar_punto_elipse(a, b, t):
    x = int(a * 2* np.cos(t) + 200)  # Desplazamiento para centrar
    y = int(b * np.sin(t) + 200)
    return (x, y)

# Dimensiones de la imagen
img_width, img_height = 600, 600

# Crear una imagen en blanco
imagen = np.zeros((img_height, img_width, 3), dtype=np.uint8)

# Parámetros de la elipse
a = 200  # Semieje mayor
b = 100  # Semieje menor
num_puntos = 1000

# Crear los valores del parámetro t para la animación
t_vals = np.linspace(0, 2 * np.pi, num_puntos)

# Bucle de animación
for t in t_vals:
    # Crear una nueva imagen en blanco en cada iteración
    imagen = np.zeros((img_height, img_width, 3), dtype=np.uint8)
    
    # Generar el punto en la elipse
    punto = generar_punto_elipse(a, b, t)
    
    # Dibujar el punto en la elipse
    cv2.circle(imagen, punto, radius=, color=(0, 255, 0), thickness=-1)
    
    # Dibujar la trayectoria completa de la elipse (opcional, si quieres ver toda la elipse)
    for t_tray in t_vals:
        pt_tray = generar_punto_elipse(a, b, t_tray)
        cv2.circle(imagen, pt_tray, radius=1, color=(255, 255, 255), thickness=-1)
    
    # Mostrar la imagen con el punto en movimiento
    cv2.imshow('img', imagen)
    
    # Controlar la velocidad de la animación (en milisegundos)
    cv2.waitKey(10)

# Cerrar la ventana después de la animación
cv2.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None


#+BEGIN_SRC python
import numpy as np
import cv2

# Definir los parámetros de la circunferencia
r = 100  # radio
h = 250  # centro en x
k = 250  # centro en y
num_frames = 100  # número de frames en la animación
t_vals = np.linspace(0, 2*np.pi, num_frames)  # valores del parámetro t

# Crear una ventana para mostrar la animación
cv2.namedWindow('Animación Circunferencia', cv2.WINDOW_AUTOSIZE)

# Animar la circunferencia
for i in range(len(t_vals)):
    t = t_vals[i]
    
    # Calcular las coordenadas del punto en la circunferencia
    x = int(h + r * np.cos(t))
    y = int(k + r * np.sin(t))
    
    # Crear una imagen en blanco
    frame = np.ones((500, 500, 3), dtype=np.uint8) * 255
    
    # Dibujar la circunferencia
    cv2.circle(frame, (h, k), r, (0, 0, 0), 2)
    
    # Dibujar el punto en movimiento
    cv2.circle(frame, (x, y), 10, (0, 0, 255), -1)
    
    # Mostrar el frame en la ventana
    cv2.imshow('Animación Circunferencia', frame)
    
    # Esperar un corto tiempo para crear la animación (ajustar velocidad)
    cv2.waitKey(50)
    
# Cerrar la ventana cuando la animación termine
cv2.destroyAllWindows()

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python 
import numpy as np
import cv2


# Definir los parámetros iniciales
width, height = 1000, 1000  # Ampliar la ventana para ver toda la figura
img = np.ones((height, width, 3), dtype=np.uint8)*255

# Parámetros de la curva de Limacon
a, b = 150, 100  # Reducir los valores de a y b para que la curva se ajuste mejor
k = 0.5# Constante de multiplicación del ángulo
theta_increment = 0.05  # Incremento del ángulo
max_theta = 2 * np.pi  # Un ciclo completo

# Centro de la imagen
center_x, center_y = width // 2, height // 2

theta = 0  # Ángulo inicial

while True:  # Bucle infinito
    # Limpiar la imagen
    img = np.ones((width, height, 3), dtype=np.uint8) * 255
    
    # Dibujar la curva completa desde 0 hasta theta
    for t in np.arange(0, theta, theta_increment):
        # Calcular las coordenadas paramétricas (x, y) para la curva de Limacon
        r = a + b * np.cos(k * t)
        x = int(center_x + r * np.cos(t))
        y = int(center_y + r * np.sin(t))
        
        # Dibujar un círculo en la posición calculada
        cv2.circle(img, (x, y), 2, (0, 234, 0), 2)  # Color rojo
        cv2.circle(img, (x-2, y-2), 2, (0, 0, 0), 2)  # Color rojo

    # Mostrar la constante k en la imagen
    #cv2.putText(img, f"k = {k:.2f}", (20, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
    
    # Mostrar la imagen
    cv2.imshow("Parametric Animation", img)
    
    # Incrementar el ángulo
    theta += theta_increment
    
    # Reiniciar theta si alcanza su valor máximo
    #if theta >= max_theta:
    #    theta = 0  # Reinicia la animación para que se repita

    # Pausar para ver la animación
    if cv2.waitKey(30) & 0xFF == 27:  # Esperar 30ms, salir con 'ESC'
        break

# Cerrar la ventana al finalizar
cv2.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None
